<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OCR Scanner - Hauler Helper</title>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <link rel="stylesheet" href="css/themes.css">
    <link rel="stylesheet" href="css/main.css">
    <style>
        /* OCR-Specific Styles Only */
        
        /* Card Containers */
        .card {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 25px;
            max-width: 1400px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .card-header {
            font-size: 16px;
            color: var(--color-primary);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 20px;
            font-weight: 600;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--border-color);
        }
        
        /* Upload Area */
        .upload-area {
            border: 3px dashed var(--border-color);
            border-radius: 8px;
            padding: 3rem 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background-color: var(--bg-tertiary);
        }

        .upload-area:hover, .upload-area.dragover {
            border-color: var(--color-primary);
            background-color: rgba(77, 212, 172, 0.1);
            transform: translateY(-2px);
        }

        .upload-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            color: var(--color-primary);
        }

        .upload-text {
            font-size: 1.1rem;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .upload-hint {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        #fileInput {
            display: none;
        }

        /* Preview Grid */
        .preview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .preview-item {
            position: relative;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s;
        }

        .preview-item:hover {
            border-color: var(--color-primary);
            transform: translateY(-2px);
        }

        .preview-item img {
            width: 100%;
            height: 200px;
            object-fit: cover;
            display: block;
        }

        .preview-item .status-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(10, 14, 26, 0.9);
            color: white;
            padding: 8px;
            font-size: 11px;
            text-align: center;
        }

        /* Options Grid */
        .options-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        
        /* Compact two-column layout */
        .controls-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .compact-card {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
        }
        
        .compact-header {
            font-size: 14px;
            color: var(--color-primary);
            margin-bottom: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .upload-area.compact {
            padding: 20px 15px;
        }
        
        /* Collapsible raw text */
        .collapsible-section {
            margin-top: 20px;
            border-top: 1px solid var(--border-color);
            padding-top: 15px;
        }
        
        .collapsible-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 10px;
            background-color: var(--bg-tertiary);
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .collapsible-header:hover {
            background-color: var(--bg-primary);
        }
        
        .collapsible-title {
            font-size: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .collapsible-icon {
            font-size: 14px;
            color: var(--text-secondary);
            transition: transform 0.3s;
        }
        
        .collapsible-icon.expanded {
            transform: rotate(180deg);
        }
        
        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        
        .collapsible-content.expanded {
            max-height: 500px;
            overflow-y: auto;
            margin-top: 15px;
        }
        
        @media (max-width: 768px) {
            .options-grid {
                grid-template-columns: 1fr;
            }
        }

        .option-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .option-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: var(--color-primary);
        }

        .option-item label {
            font-size: 13px;
            color: var(--text-primary);
            cursor: pointer;
            user-select: none;
        }

        .option-item.full-width {
            flex-direction: column;
            align-items: stretch;
            grid-column: 1 / 4;  /* Explicitly span all 3 columns */
        }
        
        @media (max-width: 768px) {
            .option-item.full-width {
                grid-column: 1;
            }
        }

        .option-item.full-width label {
            margin-bottom: 5px;
        }

        .select-input {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            font-size: 13px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        }

        .select-input:hover,
        .select-input:focus {
            border-color: var(--color-primary);
            outline: none;
        }

        /* Result Items */
        .result-item {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .result-filename {
            font-size: 13px;
            color: var(--color-primary);
            font-weight: 600;
        }

        .region-badge {
            display: inline-block;
            background-color: rgba(77, 212, 172, 0.2);
            color: var(--color-accent);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            margin-left: 10px;
        }

        .copy-button, .import-button {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .copy-button:hover, .import-button:hover {
            background-color: var(--color-primary);
            border-color: var(--color-primary);
            color: var(--bg-primary);
        }

        .import-button {
            margin-left: 8px;
            background-color: var(--color-success);
            border-color: var(--color-success);
            color: white;
        }

        .import-button:hover {
            opacity: 0.9;
        }

        .result-text {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.6;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
        }

        /* Parsed Data Display */
        .parsed-data {
            background-color: rgba(77, 212, 172, 0.1);
            border: 1px solid var(--color-primary);
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .parsed-data h4 {
            color: var(--color-primary);
            font-size: 14px;
            margin-bottom: 10px;
        }

        .data-grid {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .data-row {
            display: grid;
            grid-template-columns: 150px 1fr;
            gap: 10px;
        }

        .data-label {
            font-size: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .data-value {
            font-size: 13px;
            color: var(--text-primary);
        }

        .payout-highlight {
            color: var(--color-primary);
            font-weight: 700;
            font-size: 16px;
        }

        .commodity-tag {
            display: inline-block;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            margin-right: 6px;
            margin-bottom: 6px;
        }

        .data-list {
            list-style: none;
            padding: 0;
        }

        .data-list li {
            padding: 4px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .data-list li:last-child {
            border-bottom: none;
        }

        /* Canvas & Region Selection */
        .canvas-container {
            position: relative;
            display: inline-block;
            margin: 20px 0;
        }

        #regionCanvas {
            border: 2px solid var(--border-color);
            cursor: crosshair;
            display: block;
            max-width: 100%;
            height: auto;
        }

        .region-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 8px;
            background-color: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--color-primary), var(--color-accent));
            transition: width 0.3s ease;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            overflow: auto;
            padding: 20px;
        }
        
        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 30px;
            max-width: 90%;
            max-height: 90vh;
            overflow: auto;
            position: relative;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--border-color);
        }
        
        .modal-header h3 {
            font-size: 18px;
            color: var(--color-primary);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin: 0;
        }
        
        .close-modal {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 32px;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.2s;
        }
        
        .close-modal:hover {
            color: var(--color-danger);
        }
        
        /* Stats Display */
        .stats {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        
        .stat-box {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 4px 10px;
            background-color: var(--bg-tertiary);
            border-radius: 4px;
        }
        
        .stat-value {
            font-size: 14px;
            font-weight: 700;
            color: var(--color-primary);
        }
        
        .stat-label {
            font-size: 10px;
            color: var(--text-secondary);
            text-transform: uppercase;
        }
        
        /* Button Styles */
        .button {
            background-color: var(--color-primary);
            color: var(--bg-primary);
            border: 1px solid var(--color-primary);
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
        }
        
        .button:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }
        
        .button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .button-secondary {
            background-color: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }
        
        .button-secondary:hover {
            background-color: var(--bg-tertiary);
            border-color: var(--color-primary);
            color: var(--color-primary);
        }
        
        .button-danger {
            background-color: transparent;
            color: var(--color-danger);
            border: 1px solid var(--color-danger);
        }
        
        .button-danger:hover {
            background-color: var(--color-danger);
            color: white;
        }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            .options-grid {
                grid-template-columns: 1fr;
            }

            .data-row {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body data-theme="stardust">
    <div class="container">
        <!-- Theme Selector -->
        <div class="theme-selector">
            <select id="themeSelect" onchange="changeTheme()">
                <option value="stardust">Stardust</option>
                <option value="lux">Lux</option>
                <option value="pulse">Pulse</option>
                <option value="flow">Flow</option>
                <option value="dark">Dark</option>
                <option value="cetacean">Cetacean</option>
                <option value="wednesday">Wednesday</option>
                <option value="moonshine">Moonshine</option>
                <option value="cassette">Cassette</option>
                <option value="cargo-explorer">Cargo Explorer</option>
            </select>
        </div>

        <!-- Header -->
        <div class="header">
            <h1>OCR SCANNER</h1>
            <div class="subtitle">Screenshot to Mission Data</div>
        </div>

        <!-- Navigation -->
        <div class="nav-bar">
            <a href="index.html" class="nav-link">‚Üê Back to Hauler Helper</a>
        </div>

        <!-- Compact Controls Row -->
        <div class="controls-row">
            <!-- Upload Section -->
            <div class="compact-card">
                <div class="compact-header">üì∏ Upload Screenshots</div>
                <div class="upload-area compact" id="uploadArea">
                    <div class="upload-icon">üìÅ</div>
                    <div class="upload-text">Drag & drop or click</div>
                </div>
                <input type="file" id="fileInput" accept="image/*" multiple>
                <div id="previewContainer" class="preview-grid"></div>
            </div>
            
            <!-- Processing Options -->
            <div class="compact-card">
                <div class="compact-header">‚öôÔ∏è Processing Options</div>
                <div class="options-grid">
                    <div class="option-item">
                        <input type="checkbox" id="parseMode" checked>
                        <label for="parseMode">Parse Mission Data</label>
                    </div>
                    <div class="option-item">
                        <input type="checkbox" id="deduplicateMode">
                        <label for="deduplicateMode">Deduplicate Results</label>
                    </div>
                    <div class="option-item">
                        <input type="checkbox" id="templateMode">
                        <label for="templateMode">Use Template Mode</label>
                    </div>
                    <div class="option-item full-width">
                        <label for="psmMode">OCR Mode:</label>
                        <select id="psmMode" class="select-input">
                            <option value="3">Auto</option>
                            <option value="6" selected>Single Block (Best for SC)</option>
                            <option value="11">Sparse Text</option>
                            <option value="4">Single Column</option>
                            <option value="13">Single Line</option>
                        </select>
                    </div>
                </div>

                <div style="display: flex; gap: 10px; margin-top: 15px; flex-wrap: wrap;">
                    <button class="button" id="processBtn" disabled>Process Images</button>
                    <button class="button button-secondary" id="clearBtn" style="display: none;">Clear All</button>
                </div>
            </div>
        </div>

        <!-- Results Card -->
        <div class="card" id="resultsCard" style="display: none;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <div class="card-header" style="margin: 0;">üìÑ Extracted Data</div>
                <div class="stats" id="stats">
                    <div class="stat-box">
                        <span class="stat-value" id="totalImages">0</span>
                        <span class="stat-label">Images</span>
                    </div>
                    <div class="stat-box">
                        <span class="stat-value" id="totalWords">0</span>
                        <span class="stat-label">Words</span>
                    </div>
                    <div class="stat-box">
                        <span class="stat-value" id="totalChars">0</span>
                        <span class="stat-label">Chars</span>
                    </div>
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                <button class="button" id="importAllBtn" style="background-color: var(--color-success); display: none;">üì¶ Import All to Hauler</button>
                <button class="button button-secondary" id="exportJsonBtn">Export JSON</button>
                <button class="button button-secondary" id="exportCsvBtn">Export CSV</button>
            </div>

            <div id="resultsContainer"></div>
        </div>
    </div>

    <!-- Region Selection Modal -->
    <div class="modal" id="regionModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Select OCR Regions</h3>
                <button class="close-modal" onclick="closeRegionModal()">√ó</button>
            </div>
            <div class="canvas-container">
                <canvas id="regionCanvas"></canvas>
            </div>
            <div class="region-controls">
                <button class="button" onclick="addCurrentRegion()">Save Current Region</button>
                <button class="button button-secondary" onclick="clearCurrentRegion()">Clear Current</button>
                <button class="button button-secondary" onclick="clearAllRegions()">Clear All Regions</button>
                <button class="button button-danger" onclick="processFullImage()">Process Full Image</button>
            </div>
            <div id="regionsList" style="margin-top: 15px; color: var(--text-secondary); font-size: 12px;"></div>
        </div>
    </div>

    <footer class="footer">
        This is an unofficial Star Citizen fansite, not affiliated with the Cloud Imperium group of companies.<br>
        2025 Wednesdaywoe<br>
        <a href="https://www.youtube.com/@wednesdaywoeplays" target="_blank">youtube.com/@wednesdaywoeplays</a>
    </footer>

    <script>
        // Global state
        let selectedFiles = [];
        let fileRegions = new Map();
        let currentFile = null;
        let currentScale = 1;
        let templateRegions = null;
        let processedResults = [];
        let isDrawing = false;
        let startX, startY, currentX, currentY;
        let tempRegion = null; // Temporary region being drawn

        // DOM elements
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const previewContainer = document.getElementById('previewContainer');
        const processBtn = document.getElementById('processBtn');
        const clearBtn = document.getElementById('clearBtn');
        const resultsContainer = document.getElementById('resultsContainer');
        const resultsCard = document.getElementById('resultsCard');
        const stats = document.getElementById('stats');
        const regionModal = document.getElementById('regionModal');
        const regionCanvas = document.getElementById('regionCanvas');
        const ctx = regionCanvas.getContext('2d');
        const regionsList = document.getElementById('regionsList');
        const parseMode = document.getElementById('parseMode');
        const deduplicateMode = document.getElementById('deduplicateMode');
        const templateMode = document.getElementById('templateMode');
        const exportJsonBtn = document.getElementById('exportJsonBtn');
        const exportCsvBtn = document.getElementById('exportCsvBtn');

        // Theme management
        function changeTheme() {
            const theme = document.getElementById('themeSelect').value;
            document.body.setAttribute('data-theme', theme);
            localStorage.setItem('haulerHelperOCRTheme', theme);
        }

        function loadTheme() {
            const savedTheme = localStorage.getItem('haulerHelperOCRTheme');
            if (savedTheme) {
                document.body.setAttribute('data-theme', savedTheme);
                document.getElementById('themeSelect').value = savedTheme;
            }
        }

        // Initialize theme
        loadTheme();

        // Upload handlers
        uploadArea.addEventListener('click', () => fileInput.click());
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });
        fileInput.addEventListener('change', (e) => {
            handleFiles(e.target.files);
        });

        function handleFiles(files) {
            selectedFiles = Array.from(files);
            fileRegions.clear();
            displayPreviews();
            processBtn.disabled = false;
            clearBtn.style.display = 'inline-block';
        }

        function displayPreviews() {
            previewContainer.innerHTML = '';
            selectedFiles.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const div = document.createElement('div');
                    div.className = 'preview-item';
                    div.innerHTML = `
                        <img src="${e.target.result}" alt="${file.name}">
                        <div class="status-overlay" data-index="${index}">Ready - Click to define regions</div>
                    `;
                    div.onclick = () => openRegionModal(file, e.target.result);
                    previewContainer.appendChild(div);
                };
                reader.readAsDataURL(file);
            });
        }

        // Region selection
        function openRegionModal(file, dataUrl) {
            currentFile = { file, dataUrl };
            regionModal.classList.add('active');
            
            const img = new Image();
            img.onload = () => {
                const maxWidth = window.innerWidth * 0.8;
                const maxHeight = window.innerHeight * 0.7;
                const scale = Math.min(maxWidth / img.width, maxHeight / img.height, 1);
                currentScale = scale;
                
                regionCanvas.width = img.width * scale;
                regionCanvas.height = img.height * scale;
                
                ctx.drawImage(img, 0, 0, regionCanvas.width, regionCanvas.height);
                
                // Draw existing regions if any
                const regions = fileRegions.get(file.name) || (templateMode.checked && templateRegions) || [];
                drawRegions(regions);
                updateRegionsList(regions);
            };
            img.src = dataUrl;
        }

        function closeRegionModal() {
            regionModal.classList.remove('active');
            currentFile = null;
        }

        // Canvas drawing
        regionCanvas.addEventListener('mousedown', (e) => {
            const rect = regionCanvas.getBoundingClientRect();
            startX = e.clientX - rect.left;
            startY = e.clientY - rect.top;
            isDrawing = true;
            tempRegion = null; // Clear previous temp region
        });

        regionCanvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            
            const rect = regionCanvas.getBoundingClientRect();
            currentX = e.clientX - rect.left;
            currentY = e.clientY - rect.top;
            
            redrawCanvas();
            
            // Draw current selection
            ctx.strokeStyle = '#4dd4ac';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(startX, startY, currentX - startX, currentY - startY);
            ctx.setLineDash([]);
        });

        regionCanvas.addEventListener('mouseup', () => {
            if (isDrawing && currentX !== undefined && currentY !== undefined) {
                // Calculate region bounds
                const x = Math.min(startX, currentX);
                const y = Math.min(startY, currentY);
                const width = Math.abs(currentX - startX);
                const height = Math.abs(currentY - startY);
                
                // Store as temporary region (not saved until user clicks "Add Region")
                if (width > 10 && height > 10) {
                    tempRegion = { x, y, width, height };
                    redrawCanvas();
                    // Draw the temp region
                    ctx.strokeStyle = '#4dd4ac';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(x, y, width, height);
                    ctx.setLineDash([]);
                }
            }
            isDrawing = false;
        });

        function redrawCanvas() {
            const img = new Image();
            img.onload = () => {
                ctx.clearRect(0, 0, regionCanvas.width, regionCanvas.height);
                ctx.drawImage(img, 0, 0, regionCanvas.width, regionCanvas.height);
                
                const regions = fileRegions.get(currentFile.file.name) || (templateMode.checked && templateRegions) || [];
                drawRegions(regions);
                
                // Draw temp region if exists
                if (tempRegion) {
                    ctx.strokeStyle = '#4dd4ac';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(tempRegion.x, tempRegion.y, tempRegion.width, tempRegion.height);
                    ctx.setLineDash([]);
                }
            };
            img.src = currentFile.dataUrl;
        }

        function drawRegions(regions) {
            regions.forEach((region, index) => {
                ctx.strokeStyle = '#4dd4ac';
                ctx.lineWidth = 2;
                ctx.strokeRect(region.x, region.y, region.width, region.height);
                
                ctx.fillStyle = 'rgba(77, 212, 172, 0.2)';
                ctx.fillRect(region.x, region.y, region.width, region.height);
                
                ctx.fillStyle = '#4dd4ac';
                ctx.font = '16px sans-serif';
                ctx.fillText(`${index + 1}`, region.x + 5, region.y + 20);
            });
        }

        function addCurrentRegion() {
            if (!currentFile || (!tempRegion && startX === undefined)) {
                alert('Please draw a region first');
                return;
            }
            
            // Use tempRegion if available, otherwise calculate from current coordinates
            const region = tempRegion || {
                x: Math.min(startX, currentX),
                y: Math.min(startY, currentY),
                width: Math.abs(currentX - startX),
                height: Math.abs(currentY - startY)
            };
            
            if (templateMode.checked) {
                if (!templateRegions) templateRegions = [];
                templateRegions.push(region);
                
                // Apply to all files
                selectedFiles.forEach(file => {
                    const existingRegions = fileRegions.get(file.name) || [];
                    fileRegions.set(file.name, [...existingRegions, region]);
                });
            } else {
                const fileName = currentFile.file.name;
                const existingRegions = fileRegions.get(fileName) || [];
                fileRegions.set(fileName, [...existingRegions, region]);
            }
            
            startX = undefined;
            tempRegion = null; // Clear temp region
            redrawCanvas();
            updateRegionsList(fileRegions.get(currentFile.file.name) || templateRegions || []);
        }

        function clearCurrentRegion() {
            startX = undefined;
            redrawCanvas();
        }

        function clearAllRegions() {
            if (templateMode.checked) {
                templateRegions = null;
                fileRegions.clear();
            } else if (currentFile) {
                fileRegions.delete(currentFile.file.name);
            }
            redrawCanvas();
            updateRegionsList([]);
        }

        function processFullImage() {
            if (templateMode.checked) {
                templateRegions = null;
                fileRegions.clear();
            } else if (currentFile) {
                fileRegions.delete(currentFile.file.name);
            }
            closeRegionModal();
        }

        function updateRegionsList(regions) {
            if (regions.length === 0) {
                regionsList.innerHTML = 'No regions defined (will process full image)';
            } else {
                regionsList.innerHTML = `Regions defined: ${regions.length}`;
            }
        }

        // Star Citizen mission parser
        // Star Citizen mission parser - IMPROVED for real OCR data
        function parseStarCitizenMission(text) {
            const result = {
                payout: null,
                commodities: [],
                pickupLocations: [],
                deliveryLocations: [],
                destinationQuantities: {},  // Map destination ‚Üí quantity
                quantity: null  // Total quantity
            };
            
            // Parse payout - check all patterns and take highest value
            // (Reward amount is always higher than mission listing amounts)
            const payoutPatterns = [
                /Reward\s*\n?\s*(\d[\d,]+)/i,               // "Reward 48,750" - PRIORITY
                /(\d[\d,\s]*\d)\s*(?:aUEC|AUEC|UEC)/i,     // "40,750 aUEC"
                /(\d{2,}[,\s]\d{3})/,                         // "40,750" or "40 750"
                /(\d+)[kK]/                                     // "40k" or "85K" - LAST
            ];
            
            let highestPayout = 0;
            
            for (const pattern of payoutPatterns) {
                const match = text.match(pattern);
                if (match) {
                    let cleanNumber = match[1].replace(/[,\s]/g, '');
                    let payout = parseInt(cleanNumber);
                    
                    // Handle "K" suffix (multiply by 1000)
                    if (match[0].toLowerCase().includes('k')) {
                        payout *= 1000;
                    }
                    
                    // Keep the highest value found
                    if (payout > highestPayout && payout > 1000) {
                        highestPayout = payout;
                    }
                }
            }
            
            if (highestPayout > 0) {
                result.payout = highestPayout;
            }
            
            // Parse commodities - case insensitive
            const commodityKeywords = [
                'Aluminum', 'Beryl', 'Carbon', 'Corundum', 'Diamond', 'Gold', 
                'Hydrogen', 'Laranite', 'Quantanium', 'Quartz', 'Silicon', 'Titanium', 'Tungsten',
                'Agricultural Supplies', 'Agri Supplies', 'Medical Supplies', 
                'Processed Food', 'Proc Food', 'Waste', 'Scrap', 'Stims', 
                'Ship Ammo', 'Quantum Fuel', 'Pressurized Ice', 'Press Ice', 
                'C Materials', 'Tin'
            ];
            
            const normalizedText = text.toLowerCase();
            commodityKeywords.forEach(commodity => {
                const normalizedCommodity = commodity.toLowerCase();
                if (normalizedText.includes(normalizedCommodity)) {
                    if (!result.commodities.includes(commodity)) {
                        result.commodities.push(commodity);
                    }
                }
            });
            
            // Parse quantities - handle both single and multiple deliveries
            // For multi-delivery missions like "5 SCU to X, 7 SCU to Y", sum them up
            const quantityMatches = text.matchAll(/Deliver\s+(0[17]?\d+|\d+)\s*SCU/gi);
            let totalQuantity = 0;
            let quantityCount = 0;
            
            for (const match of quantityMatches) {
                let numStr = match[1];
                
                // Fix OCR error: "078" ‚Üí "8", "0124" ‚Üí "24"
                if (/^0[17](\d+)$/.test(numStr) && numStr.length <= 4) {
                    numStr = numStr.substring(2);
                }
                
                const qty = parseInt(numStr, 10);
                if (qty > 0) {
                    totalQuantity += qty;
                    quantityCount++;
                }
            }
            
            // If found multiple quantities, use the sum
            if (quantityCount > 0) {
                result.quantity = totalQuantity;
            } else {
                // Fallback to old single-quantity parsing
                let quantityMatch = text.match(/0\/(\d+)\s*SCU/i);
                
                if (!quantityMatch) {
                    quantityMatch = text.match(/(\d+)\s*SCU/i);
                    
                    if (quantityMatch) {
                        let numStr = quantityMatch[1];
                        if (/^0[17](\d+)$/.test(numStr) && numStr.length <= 4) {
                            numStr = numStr.substring(2);
                        }
                        result.quantity = parseInt(numStr, 10);
                    }
                } else {
                    result.quantity = parseInt(quantityMatch[1], 10);
                }
            }
            
            // Parse locations - "from [location]" and "to [location]" patterns
            // Pattern 1: "Collect [commodity] from [location]"
            const fromPattern1 = /(?:Collect|Pick up|from)\s+(?:[\w\s]+?)?from\s+([A-Za-z0-9\s\-'.]+?)(?:Lively|Station|Harbor|Lagrange|above|\.|,|\n)/gi;
            const fromMatches1 = text.matchAll(fromPattern1);
            for (const match of fromMatches1) {
                const location = match[1].trim();
                if (location && location.length > 2 && !result.pickupLocations.includes(location)) {
                    result.pickupLocations.push(location);
                }
            }
            
            // Pattern 2: Just "from [location]"
            const fromPattern2 = /from\s+([A-Z][A-Za-z0-9\-]+(?:\s+[A-Z][A-Za-z0-9\-]+)*)/g;
            const fromMatches2 = text.matchAll(fromPattern2);
            for (const match of fromMatches2) {
                const location = match[1].trim();
                if (location && location.length > 2 && !result.pickupLocations.includes(location)) {
                    result.pickupLocations.push(location);
                }
            }
            
            // Pattern 3: "Deliver X SCU to [location]" - extract both quantity and location
            const deliverPattern = /Deliver\s+(0[17]?\d+|\d+)\s*SCU\s+(?:of\s+[\w\s]+?)?to\s+([A-Za-z0-9\s\-'.]+?)(?:above|Harbor|Station|Lagrange|Point|\.|,|\n)/gi;
            const deliverMatches = text.matchAll(deliverPattern);
            for (const match of deliverMatches) {
                let qty = match[1];
                const location = match[2].trim();
                
                // Fix OCR error: "078" ‚Üí "8"
                if (/^0[17](\d+)$/.test(qty) && qty.length <= 4) {
                    qty = qty.substring(2);
                }
                
                const quantity = parseInt(qty, 10);
                
                if (location && location.length > 2) {
                    if (!result.deliveryLocations.includes(location)) {
                        result.deliveryLocations.push(location);
                    }
                    // Store quantity for this destination
                    result.destinationQuantities[location] = quantity;
                }
            }
            
            // Also check generic "to [location]" pattern for destinations without quantities
            const toPattern1 = /(?:Deliver|to)\s+(?:[\d\/]+\s+SCU\s+of\s+[\w\s]+?)?to\s+([A-Za-z0-9\s\-'.]+?)(?:above|Harbor|Station|Lagrange|\.|,|\n)/gi;
            const toMatches1 = text.matchAll(toPattern1);
            for (const match of toMatches1) {
                const location = match[1].trim();
                if (location && location.length > 2 && !result.deliveryLocations.includes(location)) {
                    result.deliveryLocations.push(location);
                }
            }
            
            // Pattern 4: Just "to [location]"
            const toPattern2 = /to\s+([A-Z][A-Za-z0-9\-]+(?:\s+[A-Z][A-Za-z0-9\-]+)*)/g;
            const toMatches2 = text.matchAll(toPattern2);
            for (const match of toMatches2) {
                const location = match[1].trim();
                if (location && location.length > 2 && !result.deliveryLocations.includes(location)) {
                    result.deliveryLocations.push(location);
                }
            }
            
            // Common SC location abbreviations
            const locationAbbrevs = [
                /(?:ARC|CRU|HUR|MIC)-L[1-5]/gi,           // ARC-L2, MIC-L1, etc
                /(?:MT|HUR|ARC|CRU)\s+L[1-5]/gi,         // MT L1, HUR L2
            ];
            
            for (const pattern of locationAbbrevs) {
                const matches = text.matchAll(pattern);
                for (const match of matches) {
                    const location = match[0].trim();
                    // Try to determine if pickup or delivery based on context
                    const beforeText = text.substring(Math.max(0, match.index - 50), match.index).toLowerCase();
                    const afterText = text.substring(match.index, Math.min(text.length, match.index + 50)).toLowerCase();
                    
                    if (beforeText.includes('from') || beforeText.includes('collect')) {
                        if (!result.pickupLocations.includes(location)) {
                            result.pickupLocations.push(location);
                        }
                    } else if (beforeText.includes('to') || beforeText.includes('deliver') || 
                               afterText.includes('deliver') || afterText.includes('to')) {
                        if (!result.deliveryLocations.includes(location)) {
                            result.deliveryLocations.push(location);
                        }
                    }
                }
            }
            
            // Clean up locations - remove common trailing words
            const cleanLocation = (loc) => {
                return loc.replace(/\s+(Station|Harbor|Lagrange|Point|above|at)$/i, '').trim();
            };
            
            // Deduplicate locations - keep shortest version
            const deduplicateLocations = (locations) => {
                const cleaned = locations.map(cleanLocation);
                const unique = [];
                
                for (const loc of cleaned) {
                    // Check if this is a substring of an existing location or vice versa
                    const isDuplicate = unique.some(existing => {
                        if (loc.includes(existing) || existing.includes(loc)) {
                            // Keep the shorter one
                            const index = unique.indexOf(existing);
                            if (loc.length < existing.length) {
                                unique[index] = loc;
                            }
                            return true;
                        }
                        return false;
                    });
                    
                    if (!isDuplicate) {
                        unique.push(loc);
                    }
                }
                
                return unique;
            };
            
            result.pickupLocations = deduplicateLocations(result.pickupLocations);
            result.deliveryLocations = deduplicateLocations(result.deliveryLocations);
            
            return result;
        }

        function aggregateUniqueValues(results) {
            const commodities = new Set();
            const locations = new Set();
            const payouts = new Set();
            
            results.forEach(result => {
                const parsed = parseStarCitizenMission(result.text);
                if (parsed.payout) payouts.add(parsed.payout);
                parsed.commodities.forEach(c => commodities.add(c));
                parsed.pickupLocations.forEach(l => locations.add(l));
                parsed.deliveryLocations.forEach(l => locations.add(l));
            });
            
            return {
                commodities: Array.from(commodities).sort(),
                allLocations: Array.from(locations).sort(),
                payouts: Array.from(payouts).sort((a, b) => a - b)
            };
        }

        // Deduplication
        function deduplicateResults(results) {
            const seen = new Set();
            return results.filter(result => {
                const key = result.text.trim().toLowerCase();
                if (seen.has(key)) return false;
                seen.add(key);
                return true;
            });
        }

        function renderResults() {
            resultsContainer.innerHTML = '';
            let resultsToShow = processedResults;
            
            if (deduplicateMode.checked) {
                resultsToShow = deduplicateResults(resultsToShow);
            }
            
            resultsToShow.forEach(result => {
                displayResult(result.filename, result.text, result.region);
            });
            
            resultsCard.style.display = 'block';
            
            // Show Import All button if we have parsed results
            const importAllBtn = document.getElementById('importAllBtn');
            const hasParsedResults = resultsToShow.some(result => {
                const parsed = parseStarCitizenMission(result.text);
                return parsed.payout || parsed.commodities.length > 0;
            });
            importAllBtn.style.display = hasParsedResults ? 'block' : 'none';
        }

        // Processing
        processBtn.addEventListener('click', async () => {
            if (selectedFiles.length === 0) return;
            
            processBtn.disabled = true;
            processBtn.textContent = 'Processing...';
            resultsContainer.innerHTML = '';
            processedResults = [];
            
            const worker = await Tesseract.createWorker();
            await worker.loadLanguage('eng');
            await worker.initialize('eng');
            
            for (let i = 0; i < selectedFiles.length; i++) {
                const file = selectedFiles[i];
                const statusEl = document.querySelector(`[data-index="${i}"]`);
                statusEl.innerHTML = 'Processing...';
                statusEl.style.background = 'rgba(77, 212, 172, 0.9)';
                
                try {
                    const imageData = await readFileAsDataURL(file);
                    const regions = fileRegions.get(file.name) || (templateMode.checked && templateRegions) || [];
                    
                    if (regions.length === 0) {
                        // Process full image
                        const psmMode = document.getElementById('psmMode').value;
                        const result = await worker.recognize(imageData, {
                            tessedit_pageseg_mode: psmMode,
                            tessedit_char_whitelist: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz -,.()[]aUEC'
                        });
                        processedResults.push({
                            filename: file.name,
                            text: result.data.text,
                            confidence: result.data.confidence,
                            region: 'Full Image'
                        });
                        statusEl.innerHTML = `‚úì Complete`;
                    } else {
                        // Process each region
                        for (let r = 0; r < regions.length; r++) {
                            const region = regions[r];
                            // Scale regions back to original image dimensions
                            const scaleBack = 1 / currentScale;
                            const rect = {
                                left: Math.round(region.x * scaleBack),
                                top: Math.round(region.y * scaleBack),
                                width: Math.round(region.width * scaleBack),
                                height: Math.round(region.height * scaleBack)
                            };
                            
                            const psmMode = document.getElementById('psmMode').value;
                            const result = await worker.recognize(imageData, { 
                                rectangle: rect,
                                tessedit_pageseg_mode: psmMode,
                                tessedit_char_whitelist: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz -,.()[]aUEC'
                            });
                            processedResults.push({
                                filename: file.name,
                                text: result.data.text,
                                confidence: result.data.confidence,
                                region: `Region ${r + 1}`
                            });
                        }
                        statusEl.innerHTML = `‚úì Complete - ${regions.length} region${regions.length > 1 ? 's' : ''}`;
                    }
                } catch (error) {
                    statusEl.innerHTML = '‚úó Error';
                    statusEl.style.background = 'rgba(239, 68, 68, 0.9)';
                    console.error('OCR Error:', error);
                }
            }
            
            await worker.terminate();
            processBtn.disabled = false;
            processBtn.textContent = 'Process Again';
            
            renderResults();
            updateStats();
        });

        clearBtn.addEventListener('click', () => {
            selectedFiles = [];
            fileRegions.clear();
            processedResults = [];
            templateRegions = null;
            previewContainer.innerHTML = '';
            resultsContainer.innerHTML = '';
            resultsCard.style.display = 'none';
            stats.style.display = 'none';
            processBtn.disabled = true;
            clearBtn.style.display = 'none';
        });


        function toggleCollapsible(header) {
            const content = header.nextElementSibling;
            const icon = header.querySelector('.collapsible-icon');
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                icon.classList.remove('expanded');
            } else {
                content.classList.add('expanded');
                icon.classList.add('expanded');
            }
        }

        function readFileAsDataURL(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function displayResult(filename, text, regionLabel) {
            const div = document.createElement('div');
            div.className = 'result-item';
            
            const isEmpty = !text.trim();
            
            let parsedHtml = '';
            if (parseMode.checked && !isEmpty) {
                const parsed = parseStarCitizenMission(text);
                
                parsedHtml = `
                    <div class="parsed-data">
                        <h4>üéØ Parsed Mission Data</h4>
                        <div class="data-grid">
                            <div class="data-row">
                                <div class="data-label">Payout:</div>
                                <div class="data-value payout-highlight">${parsed.payout ? '‚Ç° ' + parsed.payout.toLocaleString() : 'Not found'}</div>
                            </div>
                            ${parsed.quantity ? `
                            <div class="data-row">
                                <div class="data-label">Quantity:</div>
                                <div class="data-value payout-highlight">${parsed.quantity} SCU</div>
                            </div>
                            ` : ''}
                            ${parsed.commodities.length > 0 ? `
                            <div class="data-row">
                                <div class="data-label">Commodities:</div>
                                <div class="data-value">
                                    ${parsed.commodities.map(c => `<span class="commodity-tag">${c}</span>`).join('')}
                                </div>
                            </div>
                            ` : ''}
                            ${parsed.pickupLocations.length > 0 ? `
                            <div class="data-row">
                                <div class="data-label">Pickup From:</div>
                                <div class="data-value">
                                    <ul class="data-list">
                                        ${parsed.pickupLocations.map(loc => `<li>${loc}</li>`).join('')}
                                    </ul>
                                </div>
                            </div>
                            ` : ''}
                            ${parsed.deliveryLocations.length > 0 ? `
                            <div class="data-row">
                                <div class="data-label">Deliver To:</div>
                                <div class="data-value">
                                    <ul class="data-list">
                                        ${parsed.deliveryLocations.map(loc => {
                                            const qty = parsed.destinationQuantities && parsed.destinationQuantities[loc];
                                            return qty ? `<li>${loc} <strong>(${qty} SCU)</strong></li>` : `<li>${loc}</li>`;
                                        }).join('')}
                                    </ul>
                                </div>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }
            
            div.innerHTML = `
                <div class="result-header">
                    <div>
                        <div class="result-filename">üìÑ ${filename}</div>
                        <span class="region-badge">${regionLabel}</span>
                    </div>
                    <div>
                        ${!isEmpty ? '<button class="copy-button" onclick="copyText(this)">Copy Text</button>' : ''}
                        ${!isEmpty && parseMode.checked ? '<button class="import-button" onclick="importToHauler(this)">Import to Hauler</button>' : ''}
                    </div>
                </div>
                ${parsedHtml}
                ${!isEmpty && parseMode.checked ? `
                <div class="collapsible-section">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <span class="collapsible-title">üìù Raw OCR Text</span>
                        <span class="collapsible-icon">‚ñº</span>
                    </div>
                    <div class="collapsible-content">
                        <div class="result-text">${text}</div>
                    </div>
                </div>
                ` : `
                <div class="result-text">${isEmpty ? '(No text detected)' : text || '(No text detected)'}</div>
                `}
            `;
            
            resultsContainer.appendChild(div);
        }

        function copyText(button) {
            const resultItem = button.closest('.result-item');
            const text = resultItem.querySelector('.result-text').textContent;
            
            navigator.clipboard.writeText(text).then(() => {
                const originalText = button.textContent;
                button.textContent = '‚úì Copied!';
                
                setTimeout(() => {
                    button.textContent = originalText;
                }, 2000);
            });
        }

        function importToHauler(button) {
            const resultItem = button.closest('.result-item');
            const text = resultItem.querySelector('.result-text').textContent;
            const parsed = parseStarCitizenMission(text);
            
            // Store in localStorage for the main app to pick up
            const importData = {
                payout: parsed.payout,
                commodities: [],
                timestamp: Date.now()
            };
            
            // Build commodity array
            // For multi-destination missions, create one row per destination
            const commodity = parsed.commodities[0] || '';
            const pickup = parsed.pickupLocations[0] || '';
            
            // Check if we have per-destination quantities
            const hasPerDestQty = parsed.destinationQuantities && 
                                   Object.keys(parsed.destinationQuantities).length > 0;
            
            if (hasPerDestQty) {
                // Create one row per destination with its specific quantity
                parsed.deliveryLocations.forEach(destination => {
                    const qty = parsed.destinationQuantities[destination] || parsed.quantity || '';
                    importData.commodities.push({
                        commodity: commodity,
                        pickup: pickup,
                        destination: destination,
                        quantity: qty,
                        maxBoxSize: '4'
                    });
                });
            } else {
                // Single destination - create one row
                importData.commodities.push({
                    commodity: commodity,
                    pickup: pickup,
                    destination: parsed.deliveryLocations[0] || '',
                    quantity: parsed.quantity || '',
                    maxBoxSize: '4'
                });
            }
            
            // Only import if we have at least some data
            if (!importData.payout && importData.commodities.length === 0) {
                button.textContent = '‚ö†Ô∏è No Data Found';
                button.style.backgroundColor = 'var(--color-warning)';
                setTimeout(() => {
                    button.textContent = 'Import to Hauler';
                    button.style.backgroundColor = '';
                }, 3000);
                return;
            }
            
            console.log('üì§ Exporting to Hauler:', importData);
            localStorage.setItem('haulerHelperOCRImport', JSON.stringify(importData));
            
            button.textContent = '‚úì Ready to Import!';
            button.style.backgroundColor = 'var(--color-success)';
            
            // Open main app in new tab
            window.open('index.html', '_blank');
            
            setTimeout(() => {
                button.textContent = 'Import to Hauler';
                button.style.backgroundColor = '';
            }, 3000);
        }

        function importAllToHauler() {
            const allMissions = [];
            
            // Process all results and extract mission data
            processedResults.forEach(result => {
                const parsed = parseStarCitizenMission(result.text);
                
                // Skip if no valid data
                if (!parsed.payout && parsed.commodities.length === 0) {
                    return;
                }
                
                const commodity = parsed.commodities[0] || '';
                const pickup = parsed.pickupLocations[0] || '';
                
                const missionData = {
                    payout: parsed.payout,
                    commodities: []
                };
                
                // Check if we have per-destination quantities
                const hasPerDestQty = parsed.destinationQuantities && 
                                       Object.keys(parsed.destinationQuantities).length > 0;
                
                if (hasPerDestQty) {
                    // Create one row per destination with its specific quantity
                    parsed.deliveryLocations.forEach(destination => {
                        const qty = parsed.destinationQuantities[destination] || parsed.quantity || '';
                        missionData.commodities.push({
                            commodity: commodity,
                            pickup: pickup,
                            destination: destination,
                            quantity: qty,
                            maxBoxSize: '4'
                        });
                    });
                } else {
                    // Single destination - create one row
                    missionData.commodities.push({
                        commodity: commodity,
                        pickup: pickup,
                        destination: parsed.deliveryLocations[0] || '',
                        quantity: parsed.quantity || '',
                        maxBoxSize: '4'
                    });
                }
                
                allMissions.push(missionData);
            });
            
            if (allMissions.length === 0) {
                alert('No valid mission data found to import');
                return;
            }
            
            // Store all missions
            const importData = {
                missions: allMissions,
                timestamp: Date.now()
            };
            
            console.log('üì¶ Exporting all missions to Hauler:', importData);
            localStorage.setItem('haulerHelperOCRImportAll', JSON.stringify(importData));
            
            const btn = document.getElementById('importAllBtn');
            btn.textContent = `‚úì ${allMissions.length} Mission${allMissions.length > 1 ? 's' : ''} Ready!`;
            
            // Open main app in new tab
            window.open('index.html', '_blank');
            
            setTimeout(() => {
                btn.textContent = 'üì¶ Import All to Hauler';
            }, 3000);
        }

        function updateStats() {
            const totalWords = processedResults.reduce((sum, r) => 
                sum + (r.text.trim().split(/\s+/).filter(w => w.length > 0).length), 0
            );
            const totalChars = processedResults.reduce((sum, r) => 
                sum + r.text.length, 0
            );
            
            document.getElementById('totalImages').textContent = selectedFiles.length;
            document.getElementById('totalWords').textContent = totalWords.toLocaleString();
            document.getElementById('totalChars').textContent = totalChars.toLocaleString();
            stats.style.display = 'grid';
        }

        // Import All button
        const importAllBtn = document.getElementById('importAllBtn');
        importAllBtn.addEventListener('click', importAllToHauler);

        // Export functions
        exportJsonBtn.addEventListener('click', () => {
            const aggregateData = aggregateUniqueValues(processedResults);
            
            const exportData = {
                summary: {
                    totalMissions: processedResults.length,
                    uniqueCommodities: aggregateData.commodities,
                    uniqueLocations: aggregateData.allLocations,
                    uniquePayouts: aggregateData.payouts
                },
                missions: processedResults.map(result => {
                    const parsed = parseStarCitizenMission(result.text);
                    return {
                        filename: result.filename,
                        region: result.region,
                        payout: parsed.payout,
                        quantity: parsed.quantity,
                        commodities: parsed.commodities,
                        pickupLocations: parsed.pickupLocations,
                        deliveryLocations: parsed.deliveryLocations,
                        rawText: result.text
                    };
                })
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'star-citizen-missions-ocr.json';
            a.click();
            URL.revokeObjectURL(url);
        });

        exportCsvBtn.addEventListener('click', () => {
            const rows = [['Filename', 'Region', 'Payout', 'Quantity', 'Commodities', 'Pickup Locations', 'Delivery Locations']];
            
            processedResults.forEach(result => {
                const parsed = parseStarCitizenMission(result.text);
                rows.push([
                    result.filename,
                    result.region,
                    parsed.payout || '',
                    parsed.quantity ? parsed.quantity + ' SCU' : '',
                    parsed.commodities.join('; '),
                    parsed.pickupLocations.join('; '),
                    parsed.deliveryLocations.join('; ')
                ]);
            });
            
            const csv = rows.map(row => 
                row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(',')
            ).join('\n');
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'star-citizen-missions-ocr.csv';
            a.click();
            URL.revokeObjectURL(url);
        });
    </script>
</body>
</html>
