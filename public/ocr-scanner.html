<!-- 
    HAULER HELPER - OCR SCANNER
    Version: v5.0.0-OPTIMIZED
    Updated: 2025-12-12
    
    üéÆ OPTIMIZED FOR STAR CITIZEN GAME UI TEXT
    
    Enhanced Tesseract.js with preprocessing specifically tuned for game screenshots:
    
    OPTIMIZATIONS:
    ‚Ä¢ Image Enhancement: Contrast & brightness boost for glowing text
    ‚Ä¢ Auto-crop: Focus on right half where mission text appears
    ‚Ä¢ PSM Mode 6: Single block detection (best for game UIs)
    ‚Ä¢ Better logging: Console shows confidence scores
    ‚Ä¢ All Star Citizen parsing logic preserved
    
    WHY TESSERACT.JS?
    ‚Ä¢ Works from file:// (no server required during development)
    ‚Ä¢ CDN-friendly (no build system needed)
    ‚Ä¢ Proven accuracy with proper preprocessing
    ‚Ä¢ Faster initial load than alternatives
    ‚Ä¢ Your OCR mappings handle post-processing cleanup
    
    TO USE:
    1. Upload screenshots
    2. Enable "Enhance Image (Game UI)" for best results
    3. Enable "Auto-crop to Right Half" to focus on mission text
    4. Click "Process Images"
    5. Check browser console (F12) for detailed logs
    6. Click "Import to Hauler" to send to main app
    
    üéØ COMPREHENSIVE BUG FIXES - THREE CRITICAL ISSUES RESOLVED
    
    BUG 1 - QUANTITY TRUNCATION (FIXED):
    ‚Ä¢ parseQuantityString removed 2 chars: "075" ‚Üí "5" ‚ùå
    ‚Ä¢ Now: Simple leading zero removal: "075" ‚Üí "75" ‚úÖ
    
    BUG 2 - PICKUP DUPLICATES (FIXED):
    ‚Ä¢ Collect pattern found FIRST match not CLOSEST ‚ùå
    ‚Ä¢ Now: Finds ALL matches, uses LAST (closest to Deliver) ‚úÖ
    
    BUG 3A - FACILITY NUMBERS IN GARBAGE TEXT (FIXED):
    ‚Ä¢ Garbage text "actors to bring a B22" had hidden number "22" ‚ùå
    ‚Ä¢ Now: Extract numbers from garbage BEFORE removal ‚úÖ
    
    BUG 3B - COLLECT PATTERN CROSSES NEWLINES (FIXED):
    ‚Ä¢ Location capture used \s which matches newlines ‚ùå
    ‚Ä¢ Now: Use [ \t] for spaces/tabs only ‚úÖ
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OCR Scanner - Hauler Helper</title>
    <!-- Tesseract.js OCR Engine (optimized for game UIs) -->
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <!-- OCR Mappings for consistent name normalization -->
    <script src="js/data/ocr-mappings.js"></script>
    <link rel="stylesheet" href="css/themes.css">
    <link rel="stylesheet" href="css/main.css">
    <style>
        /* OCR-Specific Styles Only */
        
        /* Card Containers */
        .card {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 25px;
            max-width: 1400px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .card-header {
            font-size: 16px;
            color: var(--color-primary);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 20px;
            font-weight: 600;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--border-color);
        }
        
        /* Upload Area */
        .upload-area {
            border: 3px dashed var(--border-color);
            border-radius: 8px;
            padding: 3rem 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background-color: var(--bg-tertiary);
        }

        .upload-area:hover, .upload-area.dragover {
            border-color: var(--color-primary);
            background-color: rgba(77, 212, 172, 0.1);
            transform: translateY(-2px);
        }

        .upload-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            color: var(--color-primary);
        }

        .upload-text {
            font-size: 1.1rem;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .upload-hint {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        #fileInput {
            display: none;
        }

        /* Preview Grid */
        .preview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .preview-item {
            position: relative;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s;
        }

        .preview-item:hover {
            border-color: var(--color-primary);
            transform: translateY(-2px);
        }

        .preview-item img {
            width: 100%;
            height: 200px;
            object-fit: cover;
            display: block;
        }

        .preview-item .status-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(10, 14, 26, 0.9);
            color: white;
            padding: 8px;
            font-size: 11px;
            text-align: center;
        }

        /* Options Grid */
        .options-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        
        /* Compact two-column layout */
        .controls-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .compact-card {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
        }
        
        .compact-header {
            font-size: 14px;
            color: var(--color-primary);
            margin-bottom: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .upload-area.compact {
            padding: 20px 15px;
        }
        
        /* Collapsible raw text */
        .collapsible-section {
            margin-top: 20px;
            border-top: 1px solid var(--border-color);
            padding-top: 15px;
        }
        
        .collapsible-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 10px;
            background-color: var(--bg-tertiary);
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .collapsible-header:hover {
            background-color: var(--bg-primary);
        }
        
        .collapsible-title {
            font-size: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .collapsible-icon {
            font-size: 14px;
            color: var(--text-secondary);
            transition: transform 0.3s;
        }
        
        .collapsible-icon.expanded {
            transform: rotate(180deg);
        }
        
        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        
        .collapsible-content.expanded {
            max-height: 500px;
            overflow-y: auto;
            margin-top: 15px;
        }
        
        @media (max-width: 768px) {
            .options-grid {
                grid-template-columns: 1fr;
            }
        }

        .option-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .option-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: var(--color-primary);
        }

        .option-item label {
            font-size: 13px;
            color: var(--text-primary);
            cursor: pointer;
            user-select: none;
        }

        .option-item.full-width {
            flex-direction: column;
            align-items: stretch;
            grid-column: 1 / 4;  /* Explicitly span all 3 columns */
        }
        
        @media (max-width: 768px) {
            .option-item.full-width {
                grid-column: 1;
            }
        }

        .option-item.full-width label {
            margin-bottom: 5px;
        }

        .select-input {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            font-size: 13px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        }

        .select-input:hover,
        .select-input:focus {
            border-color: var(--color-primary);
            outline: none;
        }

        /* Result Items */
        .result-item {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .result-filename {
            font-size: 13px;
            color: var(--color-primary);
            font-weight: 600;
        }

        .region-badge {
            display: inline-block;
            background-color: rgba(77, 212, 172, 0.2);
            color: var(--color-accent);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            margin-left: 10px;
        }

        .copy-button, .import-button {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .copy-button:hover, .import-button:hover {
            background-color: var(--color-primary);
            border-color: var(--color-primary);
            color: var(--bg-primary);
        }

        .import-button {
            margin-left: 8px;
            background-color: var(--color-success);
            border-color: var(--color-success);
            color: white;
        }

        .import-button:hover {
            opacity: 0.9;
        }

        .result-text {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.6;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
        }

        /* Parsed Data Display */
        .parsed-data {
            background-color: rgba(77, 212, 172, 0.1);
            border: 1px solid var(--color-primary);
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .parsed-data h4 {
            color: var(--color-primary);
            font-size: 14px;
            margin-bottom: 10px;
        }

        .data-grid {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .data-row {
            display: grid;
            grid-template-columns: 150px 1fr;
            gap: 10px;
        }

        .data-label {
            font-size: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .data-value {
            font-size: 13px;
            color: var(--text-primary);
        }

        .payout-highlight {
            color: var(--color-primary);
            font-weight: 700;
            font-size: 16px;
        }

        .commodity-tag {
            display: inline-block;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            margin-right: 6px;
            margin-bottom: 6px;
        }

        .data-list {
            list-style: none;
            padding: 0;
        }

        .data-list li {
            padding: 4px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .data-list li:last-child {
            border-bottom: none;
        }

        /* Mission Summary Header */
        .mission-summary-header {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }

        .summary-stat {
            text-align: center;
        }

        .summary-stat .stat-label {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .summary-stat .stat-value {
            font-size: 20px;
            color: var(--text-primary);
            font-weight: 600;
        }

        /* Commodity Table */
        .commodity-table {
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
        }

        .commodity-table-header {
            display: grid;
            grid-template-columns: 2fr 2fr 2fr 1fr;
            background-color: var(--bg-tertiary);
            padding: 12px;
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
            border-bottom: 1px solid var(--border-color);
        }

        .commodity-table-row {
            display: grid;
            grid-template-columns: 2fr 2fr 2fr 1fr;
            padding: 12px;
            font-size: 13px;
            color: var(--text-primary);
            border-bottom: 1px solid var(--border-color);
            transition: background-color 0.2s;
        }

        .commodity-table-row:last-child {
            border-bottom: none;
        }

        .commodity-table-row:hover {
            background-color: rgba(77, 212, 172, 0.05);
        }

        .col-commodity {
            font-weight: 600;
        }

        .col-pickup,
        .col-delivery {
            color: var(--text-secondary);
        }

        .col-quantity {
            text-align: right;
            font-weight: 700;
            color: var(--color-primary);
        }

        /* Canvas & Region Selection */
        .canvas-container {
            position: relative;
            display: inline-block;
            margin: 20px 0;
        }

        #regionCanvas {
            border: 2px solid var(--border-color);
            cursor: crosshair;
            display: block;
            max-width: 100%;
            height: auto;
        }

        .region-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 8px;
            background-color: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--color-primary), var(--color-accent));
            transition: width 0.3s ease;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            overflow: auto;
            padding: 20px;
        }
        
        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 30px;
            max-width: 90%;
            max-height: 90vh;
            overflow: auto;
            position: relative;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--border-color);
        }
        
        .modal-header h3 {
            font-size: 18px;
            color: var(--color-primary);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin: 0;
        }
        
        .close-modal {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 32px;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.2s;
        }
        
        .close-modal:hover {
            color: var(--color-danger);
        }
        
        /* Stats Display */
        .stats {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        
        .stat-box {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 4px 10px;
            background-color: var(--bg-tertiary);
            border-radius: 4px;
        }
        
        .stat-value {
            font-size: 14px;
            font-weight: 700;
            color: var(--color-primary);
        }
        
        .stat-label {
            font-size: 10px;
            color: var(--text-secondary);
            text-transform: uppercase;
        }
        
        /* Button Styles */
        .button {
            background-color: var(--color-primary);
            color: var(--bg-primary);
            border: 1px solid var(--color-primary);
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
        }
        
        .button:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }
        
        .button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .button-secondary {
            background-color: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }
        
        .button-secondary:hover {
            background-color: var(--bg-tertiary);
            border-color: var(--color-primary);
            color: var(--color-primary);
        }
        
        .button-danger {
            background-color: transparent;
            color: var(--color-danger);
            border: 1px solid var(--color-danger);
        }
        
        .button-danger:hover {
            background-color: var(--color-danger);
            color: white;
        }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            .options-grid {
                grid-template-columns: 1fr;
            }

            .data-row {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body data-theme="stardust">
    <div class="container">
        <!-- Theme Selector -->
        <div class="theme-selector">
            <select id="themeSelect" onchange="changeTheme()">
                <option value="stardust">Stardust</option>
                <option value="lux">Lux</option>
                <option value="pulse">Pulse</option>
                <option value="flow">Flow</option>
                <option value="dark">Dark</option>
                <option value="cetacean">Cetacean</option>
                <option value="wednesday">Wednesday</option>
                <option value="moonshine">Moonshine</option>
                <option value="cassette">Cassette</option>
                <option value="cargo-explorer">Cargo Explorer</option>
            </select>
        </div>

        <!-- Header -->
        <div class="header">
            <h1>OCR SCANNER</h1>
            <div class="subtitle">Screenshot to Mission Data</div>
        </div>

        <!-- Navigation -->
        <div class="nav-bar">
            <a href="index.html" class="nav-link">‚Üê Back to Hauler Helper</a>
        </div>

        <!-- Compact Controls Row -->
        <div class="controls-row">
            <!-- Upload Section -->
            <div class="compact-card">
                <div class="compact-header">üì∏ Upload Screenshots</div>
                <div class="upload-area compact" id="uploadArea">
                    <div class="upload-icon">üìÅ</div>
                    <div class="upload-text">Drag & drop or click</div>
                </div>
                <input type="file" id="fileInput" accept="image/*" multiple>
                <div id="previewContainer" class="preview-grid"></div>
            </div>
            
            <!-- Processing Options -->
            <div class="compact-card">
                <div class="compact-header">‚öôÔ∏è Processing Options</div>
                <div class="options-grid">
                    <div class="option-item">
                        <input type="checkbox" id="parseMode" checked>
                        <label for="parseMode">Parse Mission Data</label>
                    </div>
                    <div class="option-item">
                        <input type="checkbox" id="autoCropRight" checked>
                        <label for="autoCropRight">Auto-crop to Right Half</label>
                    </div>
                    <div class="option-item">
                        <input type="checkbox" id="templateMode">
                        <label for="templateMode">Use Template Mode</label>
                    </div>
                    <div class="option-item">
                        <input type="checkbox" id="enhanceImage" checked>
                        <label for="enhanceImage">Enhance Image (Game UI)</label>
                    </div>
                    <div class="option-item full-width">
                        <label for="displayRatio">Display Ratio:</label>
                        <select id="displayRatio" class="select-input" onchange="saveDisplayRatioPreference()">
                            <option value="16:9" selected>16:9 (Standard)</option>
                            <option value="16:10">16:10 (WUXGA)</option>
                            <option value="21:9">21:9 (Ultrawide)</option>
                            <option value="32:9">32:9 (Super Ultrawide)</option>
                            <option value="4:3">4:3 (Legacy)</option>
                            <option value="5:4">5:4 (SXGA)</option>
                        </select>
                    </div>
                    <div class="option-item full-width">
                        <label for="cropRegion">Crop Region Override:</label>
                        <select id="cropRegion" class="select-input" onchange="saveCropRegionPreference()">
                            <option value="auto" selected>Auto (Based on Ratio)</option>
                            <option value="right-third">Right 1/3 (~33%)</option>
                            <option value="right-40">Right 40%</option>
                            <option value="right-half">Right 1/2 (50%)</option>
                            <option value="right-60">Right 60%</option>
                            <option value="right-70">Right 70%</option>
                        </select>
                    </div>
                    <div class="option-item full-width">
                        <label for="psmMode">OCR Mode:</label>
                        <select id="psmMode" class="select-input">
                            <option value="3">Auto OSD</option>
                            <option value="6" selected>Single Block (Best for SC)</option>
                            <option value="11">Sparse Text</option>
                            <option value="4">Single Column</option>
                        </select>
                    </div>
                </div>

                <div style="display: flex; gap: 10px; margin-top: 15px; flex-wrap: wrap;">
                    <button class="button" id="processBtn" disabled>Process Images</button>
                    <button class="button" id="importAllBtn" style="background-color: var(--color-success); display: none;">üì¶ Import All to Hauler</button>
                    <button class="button" id="importJsonBtn" onclick="document.getElementById('jsonFileInput').click()" style="background-color: var(--color-info);">üìÅ Import JSON</button>
                    <button class="button button-secondary" id="clearBtn" style="display: none;">Clear All</button>
                    <input type="file" id="jsonFileInput" accept=".json" style="display: none;" onchange="importFromJson(event)">
                </div>
            </div>
        </div>

        <!-- Results Card -->
        <div class="card" id="resultsCard" style="display: none;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <div class="card-header" style="margin: 0;">üìÑ Extracted Data</div>
                <div class="stats" id="stats">
                    <div class="stat-box">
                        <span class="stat-value" id="totalImages">0</span>
                        <span class="stat-label">Images</span>
                    </div>
                    <div class="stat-box">
                        <span class="stat-value" id="totalWords">0</span>
                        <span class="stat-label">Words</span>
                    </div>
                    <div class="stat-box">
                        <span class="stat-value" id="totalChars">0</span>
                        <span class="stat-label">Chars</span>
                    </div>
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                <button class="button button-secondary" id="exportJsonBtn">Export JSON</button>
                <button class="button button-secondary" id="exportCsvBtn">Export CSV</button>
            </div>

            <div id="resultsContainer"></div>
        </div>
    </div>

    <!-- Region Selection Modal -->
    <div class="modal" id="regionModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Select OCR Regions</h3>
                <button class="close-modal" onclick="closeRegionModal()">√ó</button>
            </div>
            <div class="canvas-container">
                <canvas id="regionCanvas"></canvas>
            </div>
            <div class="region-controls">
                <button class="button" onclick="addCurrentRegion()">Save Current Region</button>
                <button class="button button-secondary" onclick="clearCurrentRegion()">Clear Current</button>
                <button class="button button-secondary" onclick="clearAllRegions()">Clear All Regions</button>
                <button class="button button-danger" onclick="processFullImage()">Process Full Image</button>
            </div>
            <div id="regionsList" style="margin-top: 15px; color: var(--text-secondary); font-size: 12px;"></div>
        </div>
    </div>

    <footer class="footer">
        This is an unofficial Star Citizen fansite, not affiliated with the Cloud Imperium group of companies.<br>
        2025 Wednesdaywoe<br>
        <a href="https://www.youtube.com/@wednesdaywoeplays" target="_blank">youtube.com/@wednesdaywoeplays</a>
    </footer>

    <script>
        console.log('üöÄ OCR Scanner v2025.01.29.2 loaded');

        // Global state
        let selectedFiles = [];
        let fileRegions = new Map();
        let currentFile = null;
        let currentScale = 1;
        let templateRegions = null;
        let processedResults = [];
        let isDrawing = false;
        let startX, startY, currentX, currentY;
        let tempRegion = null; // Temporary region being drawn

        // DOM elements
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const previewContainer = document.getElementById('previewContainer');
        const processBtn = document.getElementById('processBtn');
        const clearBtn = document.getElementById('clearBtn');
        const resultsContainer = document.getElementById('resultsContainer');
        const resultsCard = document.getElementById('resultsCard');
        const stats = document.getElementById('stats');
        const regionModal = document.getElementById('regionModal');
        const regionCanvas = document.getElementById('regionCanvas');
        const ctx = regionCanvas.getContext('2d');
        const regionsList = document.getElementById('regionsList');
        const parseMode = document.getElementById('parseMode');
        const templateMode = document.getElementById('templateMode');
        const exportJsonBtn = document.getElementById('exportJsonBtn');
        const exportCsvBtn = document.getElementById('exportCsvBtn');

        // Theme management
        function changeTheme() {
            const theme = document.getElementById('themeSelect').value;
            document.body.setAttribute('data-theme', theme);
            localStorage.setItem('haulerHelperOCRTheme', theme);
        }

        function loadTheme() {
            const savedTheme = localStorage.getItem('haulerHelperOCRTheme');
            if (savedTheme) {
                document.body.setAttribute('data-theme', savedTheme);
                document.getElementById('themeSelect').value = savedTheme;
            }
        }

        // Auto-crop preference management
        function saveAutoCropPreference() {
            const autoCropEnabled = document.getElementById('autoCropRight').checked;
            localStorage.setItem('haulerHelperOCRAutoCrop', autoCropEnabled ? 'true' : 'false');
        }

        function loadAutoCropPreference() {
            const saved = localStorage.getItem('haulerHelperOCRAutoCrop');
            // Only override default (checked) if user explicitly saved a preference
            if (saved === 'false') {
                document.getElementById('autoCropRight').checked = false;
            } else if (saved === 'true') {
                document.getElementById('autoCropRight').checked = true;
            }
            // If no saved preference, leave at default (checked)
        }

        // Display ratio preference management
        function saveDisplayRatioPreference() {
            const ratio = document.getElementById('displayRatio').value;
            localStorage.setItem('haulerHelperOCRDisplayRatio', ratio);
            console.log('üíæ Saved display ratio preference:', ratio);
        }

        function loadDisplayRatioPreference() {
            const saved = localStorage.getItem('haulerHelperOCRDisplayRatio');
            if (saved) {
                document.getElementById('displayRatio').value = saved;
                console.log('üìÇ Loaded display ratio preference:', saved);
            }
        }

        // Crop region preference management
        function saveCropRegionPreference() {
            const region = document.getElementById('cropRegion').value;
            localStorage.setItem('haulerHelperOCRCropRegion', region);
            console.log('üíæ Saved crop region preference:', region);
        }

        function loadCropRegionPreference() {
            const saved = localStorage.getItem('haulerHelperOCRCropRegion');
            if (saved) {
                document.getElementById('cropRegion').value = saved;
                console.log('üìÇ Loaded crop region preference:', saved);
            }
        }

        // OCR state persistence
        function saveOCRState() {
            const state = {
                processedResults: processedResults,
                fileNames: selectedFiles.map(f => f.name),
                timestamp: Date.now()
            };
            localStorage.setItem('haulerHelperOCRState', JSON.stringify(state));
            console.log('üíæ Saved OCR state:', state.fileNames.length, 'files');
        }

        function loadOCRState() {
            const saved = localStorage.getItem('haulerHelperOCRState');
            if (!saved) return;

            try {
                const state = JSON.parse(saved);
                console.log('üìÇ Loading OCR state:', state.fileNames.length, 'files');
                
                // Restore processed results
                processedResults = state.processedResults || [];
                
                // Show results if we have them
                if (processedResults.length > 0) {
                    renderResults();
                    updateStats();
                    resultsCard.style.display = 'block';
                    clearBtn.style.display = 'inline-block';
                    processBtn.textContent = 'Process Again';
                    
                    // Show file info in preview area (without thumbnails)
                    previewContainer.innerHTML = state.fileNames.map((name, index) => `
                        <div class="preview-item">
                            <div class="preview-placeholder">üìÑ</div>
                            <div class="preview-filename">${name}</div>
                            <div class="preview-status" data-index="${index}">‚úì Processed</div>
                        </div>
                    `).join('');
                }
            } catch (e) {
                console.error('Error loading OCR state:', e);
                localStorage.removeItem('haulerHelperOCRState');
            }
        }

        function clearOCRState() {
            localStorage.removeItem('haulerHelperOCRState');
            console.log('üóëÔ∏è Cleared OCR state');
        }

        // Initialize theme and preferences
        loadTheme();
        loadAutoCropPreference();
        loadDisplayRatioPreference();
        loadCropRegionPreference();
        loadOCRState();

        // Auto-crop checkbox change handler
        document.getElementById('autoCropRight').addEventListener('change', saveAutoCropPreference);

        // Upload handlers
        uploadArea.addEventListener('click', () => fileInput.click());
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });
        fileInput.addEventListener('change', (e) => {
            handleFiles(e.target.files);
        });

        function handleFiles(files) {
            selectedFiles = Array.from(files);
            fileRegions.clear();
            displayPreviews();
            processBtn.disabled = false;
            clearBtn.style.display = 'inline-block';
        }

        function displayPreviews() {
            previewContainer.innerHTML = '';
            selectedFiles.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const div = document.createElement('div');
                    div.className = 'preview-item';
                    div.innerHTML = `
                        <img src="${e.target.result}" alt="${file.name}">
                        <div class="status-overlay" data-index="${index}">Ready - Click to define regions</div>
                    `;
                    div.onclick = () => openRegionModal(file, e.target.result);
                    previewContainer.appendChild(div);
                };
                reader.readAsDataURL(file);
            });
        }

        // Region selection
        function openRegionModal(file, dataUrl) {
            currentFile = { file, dataUrl };
            regionModal.classList.add('active');
            
            const img = new Image();
            img.onload = () => {
                const maxWidth = window.innerWidth * 0.8;
                const maxHeight = window.innerHeight * 0.7;
                const scale = Math.min(maxWidth / img.width, maxHeight / img.height, 1);
                currentScale = scale;
                
                regionCanvas.width = img.width * scale;
                regionCanvas.height = img.height * scale;
                
                ctx.drawImage(img, 0, 0, regionCanvas.width, regionCanvas.height);
                
                // Draw existing regions if any
                const regions = fileRegions.get(file.name) || (templateMode.checked && templateRegions) || [];
                drawRegions(regions);
                updateRegionsList(regions);
            };
            img.src = dataUrl;
        }

        function closeRegionModal() {
            regionModal.classList.remove('active');
            currentFile = null;
        }

        // Canvas drawing
        regionCanvas.addEventListener('mousedown', (e) => {
            const rect = regionCanvas.getBoundingClientRect();
            startX = e.clientX - rect.left;
            startY = e.clientY - rect.top;
            isDrawing = true;
            tempRegion = null; // Clear previous temp region
        });

        regionCanvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            
            const rect = regionCanvas.getBoundingClientRect();
            currentX = e.clientX - rect.left;
            currentY = e.clientY - rect.top;
            
            redrawCanvas();
            
            // Draw current selection
            ctx.strokeStyle = '#4dd4ac';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(startX, startY, currentX - startX, currentY - startY);
            ctx.setLineDash([]);
        });

        regionCanvas.addEventListener('mouseup', () => {
            if (isDrawing && currentX !== undefined && currentY !== undefined) {
                // Calculate region bounds
                const x = Math.min(startX, currentX);
                const y = Math.min(startY, currentY);
                const width = Math.abs(currentX - startX);
                const height = Math.abs(currentY - startY);
                
                // Store as temporary region (not saved until user clicks "Add Region")
                if (width > 10 && height > 10) {
                    tempRegion = { x, y, width, height };
                    redrawCanvas();
                    // Draw the temp region
                    ctx.strokeStyle = '#4dd4ac';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(x, y, width, height);
                    ctx.setLineDash([]);
                }
            }
            isDrawing = false;
        });

        function redrawCanvas() {
            const img = new Image();
            img.onload = () => {
                ctx.clearRect(0, 0, regionCanvas.width, regionCanvas.height);
                ctx.drawImage(img, 0, 0, regionCanvas.width, regionCanvas.height);
                
                const regions = fileRegions.get(currentFile.file.name) || (templateMode.checked && templateRegions) || [];
                drawRegions(regions);
                
                // Draw temp region if exists
                if (tempRegion) {
                    ctx.strokeStyle = '#4dd4ac';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(tempRegion.x, tempRegion.y, tempRegion.width, tempRegion.height);
                    ctx.setLineDash([]);
                }
            };
            img.src = currentFile.dataUrl;
        }

        function drawRegions(regions) {
            regions.forEach((region, index) => {
                ctx.strokeStyle = '#4dd4ac';
                ctx.lineWidth = 2;
                ctx.strokeRect(region.x, region.y, region.width, region.height);
                
                ctx.fillStyle = 'rgba(77, 212, 172, 0.2)';
                ctx.fillRect(region.x, region.y, region.width, region.height);
                
                ctx.fillStyle = '#4dd4ac';
                ctx.font = '16px sans-serif';
                ctx.fillText(`${index + 1}`, region.x + 5, region.y + 20);
            });
        }

        function addCurrentRegion() {
            if (!currentFile || (!tempRegion && startX === undefined)) {
                alert('Please draw a region first');
                return;
            }
            
            // Use tempRegion if available, otherwise calculate from current coordinates
            const region = tempRegion || {
                x: Math.min(startX, currentX),
                y: Math.min(startY, currentY),
                width: Math.abs(currentX - startX),
                height: Math.abs(currentY - startY)
            };
            
            if (templateMode.checked) {
                if (!templateRegions) templateRegions = [];
                templateRegions.push(region);
                
                // Apply to all files
                selectedFiles.forEach(file => {
                    const existingRegions = fileRegions.get(file.name) || [];
                    fileRegions.set(file.name, [...existingRegions, region]);
                });
            } else {
                const fileName = currentFile.file.name;
                const existingRegions = fileRegions.get(fileName) || [];
                fileRegions.set(fileName, [...existingRegions, region]);
            }
            
            startX = undefined;
            tempRegion = null; // Clear temp region
            redrawCanvas();
            updateRegionsList(fileRegions.get(currentFile.file.name) || templateRegions || []);
        }

        function clearCurrentRegion() {
            startX = undefined;
            redrawCanvas();
        }

        function clearAllRegions() {
            if (templateMode.checked) {
                templateRegions = null;
                fileRegions.clear();
            } else if (currentFile) {
                fileRegions.delete(currentFile.file.name);
            }
            redrawCanvas();
            updateRegionsList([]);
        }

        function processFullImage() {
            if (templateMode.checked) {
                templateRegions = null;
                fileRegions.clear();
            } else if (currentFile) {
                fileRegions.delete(currentFile.file.name);
            }
            closeRegionModal();
        }

        function updateRegionsList(regions) {
            if (regions.length === 0) {
                regionsList.innerHTML = 'No regions defined (will process full image)';
            } else {
                regionsList.innerHTML = `Regions defined: ${regions.length}`;
            }
        }

        // ============================================================================
        // CLEAN STAR CITIZEN MISSION PARSER
        // ============================================================================
        // Purpose: Extract mission data from OCR text
        // Returns: { payout: number, segments: [{ commodity, pickup, delivery, quantity }] }
        
        /**
         * Parse Star Citizen mission from OCR text
         * @param {string} text - Raw OCR text from mission screenshot
         * @returns {object} - { payout: number, segments: Array }
         */
        function parseStarCitizenMission(text) {
            console.log('üîç Parsing Star Citizen mission...');
            
            // Step 1: Extract payout
            const payout = extractPayout(text);
            
            // Step 2: Preprocess text to fix line breaks and OCR errors
            text = preprocessText(text);
            
            // Step 3: Extract commodity segments
            const segments = extractSegments(text);
            
            console.log(`‚úÖ Parsed mission: ${payout ? '‚Ç°' + payout.toLocaleString() : 'No payout'}, ${segments.length} segments`);
            
            return { payout, segments };
        }

        /**
         * Extract mission payout from text
         * Handles OCR errors where "Reward" or "=" are misread
         */
        function extractPayout(text) {
            // Pattern 1: Standard "Reward" with flexible separator
            // Handles: =, a, x, &, 1, u, √Ç¬Æ, or any garbage before the number
            // Matches: "Reward = 99,500" or "Reward 1 90,750" or "Reward √Ç¬Æ 90,250"
            // Strategy: Match "Reward", skip up to 10 chars (but not newline), then find 5+ digit number with commas
            let match = text.match(/Reward[^\n]{0,10}?(\d{2,3},\d{3}|\d{5,})/i);
            
            if (match) {
                const payout = parseInt(match[1].replace(/,/g, ''), 10);
                console.log(`  üí∞ Payout: ‚Ç°${payout.toLocaleString()}`);
                return payout;
            }
            
            // Pattern 2: OCR misread "Reward" as "EEL]" or similar
            // Matches: "EEL] = 90,250"
            match = text.match(/(?:EEL\]|REE|RRE)[^\n]{0,10}?(\d{2,3},\d{3}|\d{5,})/i);
            
            if (match) {
                const payout = parseInt(match[1].replace(/,/g, ''), 10);
                console.log(`  üí∞ Payout (alt pattern): ‚Ç°${payout.toLocaleString()}`);
                return payout;
            }
            
            console.log('  üí∞ Payout: Not found');
            return null;
        }

        /**
         * Preprocess OCR text to fix line breaks
         */
        function preprocessText(text) {
            console.log('  üìù Preprocessing text...');
            console.log('  üìù Input text (first 200 chars):', text.substring(0, 200));

            // Remove leading < or similar bullet characters from lines (UI artifact)
            text = text.replace(/^[<>\[\]‚Ä¢\-]\s*/gm, '');
            console.log('  üìù After bullet removal (first 200 chars):', text.substring(0, 200));

            // Normalize lagrange point descriptions to simple format
            // "Wide Forest Station at ArcCorp's L1 Lagrange point" -> "ARC-L1 Wide Forest"
            // Note: \s+ handles line breaks between words (common OCR artifact)
            text = text.replace(/Wide\s+Forest\s+Station\s+at\s+ArcCorp.s\s+L1\s+Lagrange\s+point/gi, 'ARC-L1 Wide Forest');
            text = text.replace(/Shallow\s+Frontier\s+Station\s+at\s+MicroTech.s\s+L1\s+Lagrange\s+point/gi, 'MIC-L1 Shallow Frontier');
            text = text.replace(/Endless\s+Odyssey\s+Station\s+at\s+Hurston.s\s+L1\s+Lagrange\s+point/gi, 'HUR-L1 Endless Odyssey');
            text = text.replace(/Evergreen\s+Harbor\s+Station\s+at\s+Crusader.s\s+L1\s+Lagrange\s+point/gi, 'CRU-L1 Evergreen Harbor');
            // Generic single-word station pattern as fallback
            text = text.replace(/(\w+)\s+Station\s+at\s+(\w+).s\s+L(\d)\s+Lagrange\s+point/gi, '$2-L$3 $1');
            console.log('  üìù After lagrange normalization (first 300 chars):', text.substring(0, 300));

            // Fix location names that break across lines
            text = text.replace(/Sakura Sun\s*\n\s*Goldenrod/gi, 'Sakura Sun Goldenrod');
            text = text.replace(/Greycat Stanton IV\s*\n\s*Production/gi, 'Greycat Stanton IV Production');
            text = text.replace(/Rayari (\w+)\s*\n\s*Research/gi, 'Rayari $1 Research');
            text = text.replace(/NB Int\.?\s*\n\s*Spaceport/gi, 'NB Int. Spaceport');
            
            // Fix facility codes that break across lines
            text = text.replace(/SMO-\s*\n\s*(\d+)/gi, 'SMO-$1');
            text = text.replace(/SM0-\s*\n\s*(\d+)/gi, 'SMO-$1');
            text = text.replace(/SMCa-\s*\n\s*(\d+)/gi, 'SMCa-$1');
            text = text.replace(/S4DC\s*\n\s*(\d+)/gi, 'S4DC$1');
            text = text.replace(/S4LD\s*\n\s*(\d+)/gi, 'S4LD$1');
            
            // Join "Mining" or "Facility" prefix with code
            text = text.replace(/Mining\s*\n\s*(SMO-?\d+|SMCa-?\d+)/gi, 'Mining $1');
            text = text.replace(/Facility\s*\n\s*(SMO-?\d+|S4DC\d+)/gi, 'Facility $1');
            
            return text;
        }

        /**
         * Extract commodity segments
         */
        function extractSegments(text) {
            console.log('  üöö Extracting delivery segments...');
            console.log('  üöö Full preprocessed text for regex:', text);
            const segments = [];

            // Pattern: "Deliver 0/3 SCU of Stims to Shubin Mining Facility SMCa-6 on Calliope"
            // Also handles "Deliver 0/6 SCU of Medical Supplies to ARC-L1 Wide Forest."
            const deliverPattern = /Deliver\s+(0\/\d+|\d+)\s+SCU\s+(?:of\s+)?([\w\s\(\)]+?)\s+to\s+([\w\s\-\.\']+?)(?:\s+(?:on|above|at)\s+[\w\s\-\.\']+?)?(?:\.|$)/gi;
            
            let match;
            while ((match = deliverPattern.exec(text)) !== null) {
                const quantityStr = match[1];
                const commodityRaw = match[2].trim();
                const deliveryRaw = match[3].trim();
                const deliverPos = match.index;
                
                const quantity = parseQuantity(quantityStr);
                const commodity = cleanCommodity(commodityRaw);
                const delivery = cleanLocation(deliveryRaw);
                const pickup = findPickupLocation(text, commodity, deliverPos);
                
                if (pickup && delivery && commodity && quantity > 0) {
                    segments.push({ commodity, pickup, delivery, quantity });
                    console.log(`    ‚úì ${quantity} ${commodity}: ${pickup} ‚Üí ${delivery}`);
                } else {
                    console.log(`    ‚ö†Ô∏è Incomplete segment (skipping):`, { commodity, pickup, delivery, quantity });
                }
            }
            
            console.log(`  ‚úÖ Extracted ${segments.length} segments`);
            return segments;
        }

        /**
         * Parse quantity from OCR text
         */
        function parseQuantity(str) {
            // Handle "0/3" format
            if (str.includes('/')) {
                const parts = str.split('/');
                return parseInt(parts[1], 10);
            }
            
            // Remove leading zeros
            const cleaned = str.replace(/^0+/, '') || '0';
            return parseInt(cleaned, 10);
        }

        /**
         * Clean commodity name using OCR mappings
         */
        function cleanCommodity(commodity) {
            let cleaned = commodity.replace(/\s*\([^)]+\)\s*/g, ' ').trim();
            
            if (window.OCR_MAPPINGS) {
                cleaned = window.OCR_MAPPINGS.applyCommodityAlias(cleaned);
            }
            
            return cleaned;
        }

        /**
         * Clean location name using OCR mappings
         */
        function cleanLocation(location) {
            let cleaned = location.trim();
            
            if (window.OCR_MAPPINGS) {
                cleaned = window.OCR_MAPPINGS.applyLocationAlias(cleaned);
            }
            
            return cleaned;
        }

        /**
         * Find pickup location by searching backwards
         */
        function findPickupLocation(text, commodity, deliverPos) {
            const searchStart = Math.max(0, deliverPos - 1000);
            const textBefore = text.substring(searchStart, deliverPos);
            
            const commodityPattern = commodity.replace(/\s+/g, '\\s+');
            const collectPattern = new RegExp(
                `Collect\\s+${commodityPattern}\\s+(?:\\([^)]+\\)\\s+)?from\\s+([\\w\\s\\-\\.\']+?)(?:\\.|\\n)`,
                'gi'
            );
            
            const matches = Array.from(textBefore.matchAll(collectPattern));
            
            if (matches.length > 0) {
                const lastMatch = matches[matches.length - 1];
                const pickupRaw = lastMatch[1].trim();
                return cleanLocation(pickupRaw);
            }
            
            return null;
        }

        // ============================================================================
        // END CLEAN PARSER
        // ============================================================================

        function aggregateUniqueValues(results) {
            const commodities = new Set();
            const locations = new Set();
            const payouts = new Set();
            
            results.forEach(result => {
                const parsed = result.parsedData || parseStarCitizenMission(result.text);
                if (parsed.payout) payouts.add(parsed.payout);
                
                // Extract commodities and locations from segments
                parsed.segments.forEach(seg => {
                    commodities.add(seg.commodity);
                    locations.add(seg.pickup);
                    locations.add(seg.delivery);
                });
            });
            
            return {
                commodities: Array.from(commodities).sort(),
                allLocations: Array.from(locations).sort(),
                payouts: Array.from(payouts).sort((a, b) => a - b)
            };
        }

        function renderResults() {
            resultsContainer.innerHTML = '';
            console.log(`üìä renderResults called with ${processedResults.length} results, parseMode=${parseMode.checked}`);

            processedResults.forEach((result, index) => {
                console.log(`  Result ${index + 1}: ${result.filename}, text length: ${result.text?.length || 0}`);
                // Ensure parsedData exists (for backwards compatibility with old saved sessions)
                if (!result.parsedData && result.text && parseMode.checked) {
                    result.parsedData = parseStarCitizenMission(result.text);
                    console.log(`üìù Re-parsed mission ${index + 1} (missing parsedData)`);
                }

                displayResult(result.filename, result.text, result.region);
            });
            
            resultsCard.style.display = 'block';
            
            // Show Import All button if we have parsed results
            const importAllBtn = document.getElementById('importAllBtn');
            const hasParsedResults = processedResults.some(result => {
                const parsed = result.parsedData || parseStarCitizenMission(result.text);
                return parsed.payout || parsed.segments.length > 0;
            });
            importAllBtn.style.display = hasParsedResults ? 'block' : 'none';
        }

        // Processing
        processBtn.addEventListener('click', async () => {
            if (selectedFiles.length === 0) return;
            
            processBtn.disabled = true;
            processBtn.textContent = 'Initializing OCR...';
            resultsContainer.innerHTML = '';
            processedResults = [];
            
            try {
                // Create Tesseract worker with optimized settings
                const worker = await Tesseract.createWorker('eng', 1, {
                    logger: m => console.log('[Tesseract]', m)
                });
                
                processBtn.textContent = 'Processing...';
                
                // Get settings
                const autoCropEnabled = document.getElementById('autoCropRight').checked;
                const enhanceEnabled = document.getElementById('enhanceImage').checked;
                const psmMode = document.getElementById('psmMode').value;
                
                console.log('OCR Settings:', {
                    autoCrop: autoCropEnabled,
                    enhance: enhanceEnabled,
                    psmMode: psmMode
                });
                
                for (let i = 0; i < selectedFiles.length; i++) {
                    const file = selectedFiles[i];
                    const statusEl = document.querySelector(`[data-index="${i}"]`);
                    statusEl.innerHTML = 'Processing...';
                    statusEl.style.background = 'rgba(77, 212, 172, 0.9)';
                    
                    try {
                        let imageData = await readFileAsDataURL(file);
                        
                        // Apply enhancements in sequence
                        if (autoCropEnabled) {
                            imageData = await cropImageToRightHalf(imageData);
                        }
                        
                        if (enhanceEnabled) {
                            imageData = await enhanceImageForOCR(imageData);
                        }
                        
                        const regions = fileRegions.get(file.name) || (templateMode.checked && templateRegions) || [];
                        
                        if (regions.length === 0) {
                            // Process full image
                            console.log(`Processing ${file.name} with PSM mode ${psmMode}`);
                            const result = await worker.recognize(imageData, {
                                tessedit_pageseg_mode: parseInt(psmMode)
                            });
                            
                            processedResults.push({
                                filename: file.name,
                                text: result.data.text,
                                confidence: result.data.confidence,
                                region: autoCropEnabled ? 'Right Half (Enhanced)' : 'Full Image (Enhanced)'
                            });
                            
                            console.log(`‚úì ${file.name} - Confidence: ${result.data.confidence.toFixed(1)}%`);
                            statusEl.innerHTML = `‚úì Complete (${result.data.confidence.toFixed(0)}%)`;
                        } else {
                            // Process each region
                            for (let r = 0; r < regions.length; r++) {
                                const region = regions[r];
                                const scaleBack = 1 / currentScale;
                                const rect = {
                                    left: Math.round(region.x * scaleBack),
                                    top: Math.round(region.y * scaleBack),
                                    width: Math.round(region.width * scaleBack),
                                    height: Math.round(region.height * scaleBack)
                                };
                                
                                const croppedImageData = await cropImageToRegion(imageData, rect);
                                const result = await worker.recognize(croppedImageData, {
                                    tessedit_pageseg_mode: parseInt(psmMode)
                                });
                                
                                processedResults.push({
                                    filename: file.name,
                                    text: result.data.text,
                                    confidence: result.data.confidence,
                                    region: `Region ${r + 1}`
                                });
                            }
                            statusEl.innerHTML = `‚úì Complete - ${regions.length} region${regions.length > 1 ? 's' : ''}`;
                        }
                    } catch (error) {
                        statusEl.innerHTML = '‚úó Error';
                        statusEl.style.background = 'rgba(239, 68, 68, 0.9)';
                        console.error('OCR Error:', error);
                    }
                }
                
                await worker.terminate();
                processBtn.disabled = false;
                processBtn.textContent = 'Process Again';
                
                renderResults();
                updateStats();
                saveOCRState();
                
            } catch (error) {
                console.error('OCR Initialization Error:', error);
                processBtn.disabled = false;
                processBtn.textContent = 'Process Images';
                alert('OCR initialization failed. Please refresh the page.\n\nError: ' + error.message);
            }
        });

        clearBtn.addEventListener('click', () => {
            selectedFiles = [];
            fileRegions.clear();
            processedResults = [];
            templateRegions = null;
            previewContainer.innerHTML = '';
            resultsContainer.innerHTML = '';
            resultsCard.style.display = 'none';
            stats.style.display = 'none';
            processBtn.disabled = true;
            clearBtn.style.display = 'none';
            
            // Clear saved OCR state
            clearOCRState();
        });


        function toggleCollapsible(header) {
            const content = header.nextElementSibling;
            const icon = header.querySelector('.collapsible-icon');
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                icon.classList.remove('expanded');
            } else {
                content.classList.add('expanded');
                icon.classList.add('expanded');
            }
        }

        // Helper function to calculate crop percentage based on display ratio and settings
        function calculateCropPercentage() {
            const cropRegion = document.getElementById('cropRegion').value;
            
            // If manual override is set, use it
            if (cropRegion !== 'auto') {
                const manualCrops = {
                    'right-third': 0.333,
                    'right-40': 0.40,
                    'right-half': 0.50,
                    'right-60': 0.60,
                    'right-70': 0.70
                };
                return manualCrops[cropRegion];
            }
            
            // Otherwise, calculate based on display ratio
            const displayRatio = document.getElementById('displayRatio').value;
            
            // Aspect ratio to crop percentage mapping
            // Based on where Star Citizen UI positions mission terminals
            const ratioCrops = {
                '16:9': 0.385,   // Standard (current default: 1/2.6)
                '16:10': 0.40,   // Slightly wider content area
                '21:9': 0.35,    // Ultrawide - UI more centered
                '32:9': 0.30,    // Super ultrawide - UI even more centered
                '4:3': 0.45,     // Legacy - UI takes more space
                '5:4': 0.45      // Similar to 4:3
            };
            
            return ratioCrops[displayRatio] || 0.385; // Default to 16:9 if unknown
        }

        // Helper function to crop image to right portion based on settings
        function cropImageToRightHalf(imageDataUrl) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Calculate crop percentage based on display ratio and user settings
                    const cropPercentage = calculateCropPercentage();
                    const cropWidth = Math.floor(img.width * cropPercentage);
                    const cropHeight = img.height;
                    const startX = img.width - cropWidth; // Start from right edge minus crop width
                    
                    canvas.width = cropWidth;
                    canvas.height = cropHeight;
                    
                    console.log(`‚úåÔ∏è Cropping to right ${(cropPercentage * 100).toFixed(1)}% of image (${cropWidth}px / ${img.width}px)`);
                    
                    // Draw the right portion of the image
                    ctx.drawImage(
                        img,
                        startX, 0,              // Source x, y
                        cropWidth, cropHeight,  // Source width, height
                        0, 0,                   // Destination x, y
                        cropWidth, cropHeight   // Destination width, height
                    );
                    
                    // Return cropped image as data URL
                    resolve(canvas.toDataURL('image/png'));
                };
                img.onerror = reject;
                img.src = imageDataUrl;
            });
        }

        // Enhance image for game UI text (contrast, brightness, noise reduction)
        function enhanceImageForOCR(imageDataUrl) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    canvas.width = img.width;
                    canvas.height = img.height;
                    
                    // Draw original image
                    ctx.drawImage(img, 0, 0);
                    
                    // Get image data
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    // Apply enhancements optimized for game UI text
                    // 1. Increase contrast (helps with glowing text)
                    // 2. Adjust brightness
                    // 3. Reduce color noise
                    const contrast = 1.3;  // Boost contrast
                    const brightness = 10; // Slight brightness increase
                    
                    for (let i = 0; i < data.length; i += 4) {
                        // Apply contrast and brightness to RGB
                        data[i] = Math.min(255, Math.max(0, contrast * (data[i] - 128) + 128 + brightness));     // R
                        data[i + 1] = Math.min(255, Math.max(0, contrast * (data[i + 1] - 128) + 128 + brightness)); // G
                        data[i + 2] = Math.min(255, Math.max(0, contrast * (data[i + 2] - 128) + 128 + brightness)); // B
                        // Alpha channel (data[i + 3]) stays the same
                    }
                    
                    // Put enhanced data back
                    ctx.putImageData(imageData, 0, 0);
                    
                    // Return enhanced image
                    resolve(canvas.toDataURL('image/png'));
                };
                img.onerror = reject;
                img.src = imageDataUrl;
            });
        }

        // Helper function to crop image to a specific region (rectangle)
        function cropImageToRegion(imageDataUrl, rect) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Set canvas to region size
                    canvas.width = rect.width;
                    canvas.height = rect.height;
                    
                    // Draw the specific region
                    ctx.drawImage(
                        img,
                        rect.left, rect.top,        // Source x, y
                        rect.width, rect.height,    // Source width, height
                        0, 0,                       // Destination x, y (start at 0,0)
                        rect.width, rect.height     // Destination width, height
                    );
                    
                    // Return cropped region as data URL
                    resolve(canvas.toDataURL('image/png'));
                };
                img.onerror = reject;
                img.src = imageDataUrl;
            });
        }

        function readFileAsDataURL(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function displayResult(filename, text, regionLabel) {
            const div = document.createElement('div');
            div.className = 'result-item';
            
            // Add index to find this result later
            const resultIndex = processedResults.findIndex(r => r.filename === filename && r.region === regionLabel);
            div.setAttribute('data-result-index', resultIndex);
            
            const isEmpty = !text.trim();
            
            let parsedHtml = '';
            let parsed = null;
            if (parseMode.checked && !isEmpty) {
                // Parse mission using clean parser
                const result = parseStarCitizenMission(text);
                const payout = result.payout;
                const commodityRows = result.segments; // Already in the right format!
                const calculatedTotal = result.segments.reduce((sum, seg) => sum + seg.quantity, 0);
                
                parsedHtml = `
                    <div class="parsed-data">
                        <div class="mission-summary-header">
                            <div class="summary-stat">
                                <div class="stat-label">üí∞ Payout</div>
                                <div class="stat-value payout-highlight">${payout ? '‚Ç° ' + payout.toLocaleString() : 'Not found'}</div>
                            </div>
                            <div class="summary-stat">
                                <div class="stat-label">üì¶ Total SCU</div>
                                <div class="stat-value payout-highlight">${calculatedTotal || '?'}</div>
                            </div>
                            <div class="summary-stat">
                                <div class="stat-label">üìã Commodities</div>
                                <div class="stat-value">${commodityRows.length} rows</div>
                            </div>
                        </div>
                        
                        ${commodityRows.length > 0 ? `
                        <div class="commodity-table">
                            <div class="commodity-table-header">
                                <div class="col-commodity">Commodity</div>
                                <div class="col-pickup">Pickup</div>
                                <div class="col-delivery">Delivery</div>
                                <div class="col-quantity">SCU</div>
                            </div>
                            ${commodityRows.map(row => `
                                <div class="commodity-table-row">
                                    <div class="col-commodity">${row.commodity}</div>
                                    <div class="col-pickup">${row.pickup}</div>
                                    <div class="col-delivery">${row.delivery}</div>
                                    <div class="col-quantity">${row.quantity}</div>
                                </div>
                            `).join('')}
                        </div>
                        ` : `
                        <div class="empty-state" style="padding: 20px; text-align: center; color: var(--text-secondary);">
                            ‚ö†Ô∏è No commodity data extracted
                        </div>
                        `}
                    </div>
                `;
                
                // Store parsed result for import
                if (resultIndex >= 0) {
                    processedResults[resultIndex].parsedData = result; // { payout, segments }
                }
            }
            
            div.innerHTML = `
                <div class="result-header">
                    <div>
                        <div class="result-filename">üìÑ ${filename}</div>
                        <span class="region-badge">${regionLabel}</span>
                    </div>
                    <div>
                        ${!isEmpty ? '<button class="copy-button" onclick="copyText(this)">Copy Text</button>' : ''}
                        ${!isEmpty && parseMode.checked ? '<button class="import-button" onclick="importToHauler(this)">Import to Hauler</button>' : ''}
                    </div>
                </div>
                ${parsedHtml}
                ${!isEmpty && parseMode.checked ? `
                <div class="collapsible-section">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <span class="collapsible-title">üìù Raw OCR Text</span>
                        <span class="collapsible-icon">‚ñº</span>
                    </div>
                    <div class="collapsible-content">
                        <div class="result-text">${text}</div>
                    </div>
                </div>
                ` : `
                <div class="result-text">${isEmpty ? '(No text detected)' : text || '(No text detected)'}</div>
                `}
            `;
            
            resultsContainer.appendChild(div);
        }

        function copyText(button) {
            const resultItem = button.closest('.result-item');
            const text = resultItem.querySelector('.result-text').textContent;
            
            navigator.clipboard.writeText(text).then(() => {
                const originalText = button.textContent;
                button.textContent = '‚úì Copied!';
                
                setTimeout(() => {
                    button.textContent = originalText;
                }, 2000);
            });
        }

        // UPDATED: Import single mission using segment-based parser
        // Clean location names for Hauler Helper compatibility
        function cleanLocationName(location) {
            if (!location) return '';
            
            // üÜï STEP 1: Apply OCR alias mapping FIRST
            if (window.OCR_MAPPINGS) {
                const normalized = window.OCR_MAPPINGS.applyLocationAlias(location);
                if (normalized !== location) {
                    console.log(`üó∫Ô∏è Location alias: "${location}" ‚Üí "${normalized}"`);
                    return normalized;
                }
            }
            
            // STEP 2: Strip facility prefixes that don't match database format
            const prefixes = [
                'Shubin Mining Facility ',
                'Shubin Mining Outpost ',
                'Shubin ',
                'Covalex Distribution Center ',
                'MT Logistics ',
                'SMO '
            ];
            
            let cleaned = location;
            for (const prefix of prefixes) {
                if (cleaned.startsWith(prefix)) {
                    cleaned = cleaned.substring(prefix.length);
                    break;
                }
            }
            
            cleaned = cleaned.trim();
            
            // STEP 3: Convert SMO-XX format to "Shubin SMO-XX" format
            const smoMatch = cleaned.match(/^SMO-(\d{2})$/i);
            if (smoMatch) {
                const facilityNum = smoMatch[1];
                cleaned = `Shubin SMO-${facilityNum}`;
                console.log(`üîÑ Converted SMO-${facilityNum} ‚Üí ${cleaned}`);
            }
            
            // Handle facility codes like S4DC05 ‚Üí Covalex S4DC05
            if (cleaned.match(/^S4DC\d{2}$/i)) {
                cleaned = `Covalex ${cleaned}`;
                console.log(`üîÑ Added Covalex prefix ‚Üí ${cleaned}`);
            }
            
            // Handle S4LD codes ‚Üí MicroTech S4LDXX
            if (cleaned.match(/^S4LD\d{2}$/i)) {
                cleaned = `MicroTech ${cleaned}`;
                console.log(`üîÑ Added MicroTech prefix ‚Üí ${cleaned}`);
            }
            
            return cleaned;
        }

        // Clean and normalize commodity names from OCR
        function cleanCommodityName(commodity) {
            if (!commodity) return '';
            
            let cleaned = commodity.trim();
            
            // üÜï STEP 1: Apply OCR alias mapping FIRST
            if (window.OCR_MAPPINGS) {
                const normalized = window.OCR_MAPPINGS.applyCommodityAlias(cleaned);
                if (normalized !== cleaned) {
                    console.log(`üì¶ Commodity alias: "${cleaned}" ‚Üí "${normalized}"`);
                    return normalized;
                }
            }
            
            // STEP 2: Remove (Raw) suffix if not already handled
            cleaned = cleaned.replace(/\s*\(Raw\)\s*/gi, '').trim();
            
            return cleaned;
        }



        function importToHauler(button) {
            const resultItem = button.closest('.result-item');
            const resultIndex = parseInt(resultItem.getAttribute('data-result-index'));
            const result = processedResults[resultIndex];
            
            console.log('üì¶ Importing mission:', result);
            
            const importData = {
                missions: [{
                    payout: '',
                    commodities: []
                }]
            };
            
            // Use parsed data from clean parser
            if (result.parsedData) {
                const parsed = result.parsedData;
                console.log('‚úÖ Using parsed data:', parsed.segments.length, 'segments');
                
                // Set payout
                if (parsed.payout) {
                    importData.missions[0].payout = parsed.payout;
                }
                
                // Add commodity rows (already in correct format!)
                parsed.segments.forEach(seg => {
                    importData.missions[0].commodities.push({
                        commodity: cleanCommodityName(seg.commodity),
                        pickup: cleanLocationName(seg.pickup),
                        destination: cleanLocationName(seg.delivery),
                        quantity: seg.quantity,
                        maxBoxSize: '4'
                    });
                    console.log(`  ‚úì Added: ${seg.quantity} ${seg.commodity} from ${seg.pickup} to ${seg.delivery}`);
                });
                
                // Save and indicate success
                if (importData.missions[0].commodities.length > 0 || importData.missions[0].payout) {
                    console.log('üì§ Exporting to Hauler:', importData);
                    importData.timestamp = Date.now();
                    localStorage.setItem('haulerHelperOCRImport', JSON.stringify(importData));
                    
                    button.textContent = '‚úì Ready to Import!';
                    button.style.backgroundColor = 'var(--color-success)';
                    return;
                }
            }
            
            // FALLBACK: Parse from text if no parsed data available
            console.log('‚ö†Ô∏è  No parsed data, attempting to parse from text');
            const text = result.text || resultItem.querySelector('.result-text').textContent;
            const freshParsed = parseStarCitizenMission(text);
            
            console.log('üì¶ Freshly parsed:', freshParsed.segments.length, 'segments');
            
            // Get payout
            if (freshParsed.payout) {
                importData.missions[0].payout = freshParsed.payout;
            }
            
            // Add each segment as a commodity row
            freshParsed.segments.forEach(seg => {
                importData.missions[0].commodities.push({
                    commodity: cleanCommodityName(seg.commodity),
                    pickup: cleanLocationName(seg.pickup),
                    destination: cleanLocationName(seg.delivery),
                    quantity: seg.quantity,
                    maxBoxSize: '4'
                });
                console.log(`  ‚úì Added: ${seg.quantity} ${seg.commodity} from ${seg.pickup} to ${seg.delivery}`);
            });
            
            // Only import if we have at least some data
            if (!importData.missions[0].payout && importData.missions[0].commodities.length === 0) {
                button.textContent = '‚ö†Ô∏è No Data Found';
                button.style.backgroundColor = 'var(--color-warning)';
                setTimeout(() => {
                    button.textContent = 'Import to Hauler';
                    button.style.backgroundColor = '';
                }, 3000);
                return;
            }
            
            console.log('üì§ Exporting to Hauler:', importData);
            importData.timestamp = Date.now();
            localStorage.setItem('haulerHelperOCRImport', JSON.stringify(importData));
            console.log('üíæ localStorage saved:', JSON.parse(localStorage.getItem('haulerHelperOCRImport')));
            
            button.textContent = '‚úì Ready to Import!';
            button.style.backgroundColor = 'var(--color-success)';
            
            // Auto-navigate to Hauler Helper
            setTimeout(() => {
                window.location.href = 'index.html';
            }, 1000);
        }

        // üÜï UPDATED: Import all missions using segment-based approach
        function importAllToHauler() {
            const allMissions = [];
            
            processedResults.forEach((result, index) => {
                console.log(`üì¶ Processing mission ${index + 1}:`, result);
                
                const missionData = {
                    payout: '',
                    commodities: []
                };
                
                // Use parsed data if available
                if (result.parsedData) {
                    const parsed = result.parsedData;
                    console.log(`‚úÖ Using parsed data for mission ${index + 1}:`, parsed.segments.length, 'segments');
                    
                    // Set payout
                    if (parsed.payout) {
                        missionData.payout = parsed.payout;
                    }
                    
                    // Add commodity rows
                    parsed.segments.forEach(seg => {
                        missionData.commodities.push({
                            commodity: cleanCommodityName(seg.commodity),
                            pickup: cleanLocationName(seg.pickup),
                            destination: cleanLocationName(seg.delivery),
                            quantity: seg.quantity,
                            maxBoxSize: '4'
                        });
                    });
                } else {
                    // FALLBACK: Parse from text if no parsed data
                    console.log(`‚ö†Ô∏è  No parsed data for mission ${index + 1}, parsing from text`);
                    const freshParsed = parseStarCitizenMission(result.text);
                    
                    // Skip if no useful data
                    if (!freshParsed.payout && freshParsed.segments.length === 0) {
                        console.log(`‚è≠Ô∏è  Skipping mission ${index + 1} (no data)`);
                        return;
                    }
                    
                    // Get payout
                    missionData.payout = freshParsed.payout || '';
                    
                    // Add segments
                    freshParsed.segments.forEach(seg => {
                        missionData.commodities.push({
                            commodity: cleanCommodityName(seg.commodity),
                            pickup: cleanLocationName(seg.pickup),
                            destination: cleanLocationName(seg.delivery),
                            quantity: seg.quantity,
                            maxBoxSize: '4'
                        });
                    });
                }
                
                // Add to missions if we have data
                if (missionData.commodities.length > 0 || missionData.payout) {
                    allMissions.push(missionData);
                    console.log(`  ‚úì Added mission ${index + 1}: ${missionData.payout}, ${missionData.commodities.length} rows`);
                }
            });
            
            if (allMissions.length === 0) {
                alert('No valid missions found to import. Please check the OCR results.');
                return;
            }
            
            const importData = {
                missions: allMissions,
                timestamp: Date.now()
            };
            
            console.log('üì§ Exporting all missions to Hauler:', importData);
            localStorage.setItem('haulerHelperOCRImport', JSON.stringify(importData));
            console.log('üíæ localStorage saved:', JSON.parse(localStorage.getItem('haulerHelperOCRImport')));
            
            // Update button
            const btn = document.getElementById('importAllBtn');
            btn.textContent = `‚úì ${allMissions.length} Missions Ready!`;
            btn.style.backgroundColor = 'var(--color-success)';
            
            // Auto-navigate to Hauler Helper after showing success message
            setTimeout(() => {
                window.location.href = 'index.html';
            }, 1000);
        }

        // Import mission data from JSON file
        function importFromJson(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            console.log('üìÅ Loading JSON file:', file.name);
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const jsonData = JSON.parse(e.target.result);
                    console.log('‚úÖ Parsed JSON:', jsonData);
                    
                    // Check if it's the expected format
                    if (!jsonData.missions || !Array.isArray(jsonData.missions)) {
                        alert('Invalid JSON format. Expected a "missions" array.');
                        return;
                    }
                    
                    // Convert JSON missions to import format
                    const allMissions = [];
                    
                    // üÜï Parse each mission from JSON and convert to segments
                    jsonData.missions.forEach((mission, index) => {
                        console.log(`üìä Processing JSON mission ${index + 1}:`, mission);
                        
                        const missionData = {
                            payout: mission.payout || '',
                            commodities: []
                        };
                        
                        // Re-parse raw text to get segments (best accuracy)
                        if (mission.rawText) {
                            const parsed = parseStarCitizenMission(mission.rawText);
                            console.log(`  ‚úÖ Extracted ${parsed.segments.length} segments from raw text`);
                            
                            // Set payout
                            if (parsed.payout) {
                                missionData.payout = parsed.payout;
                            }
                            
                            // Add segments
                            parsed.segments.forEach(seg => {
                                missionData.commodities.push({
                                    commodity: cleanCommodityName(seg.commodity),
                                    pickup: cleanLocationName(seg.pickup),
                                    destination: cleanLocationName(seg.delivery),
                                    quantity: seg.quantity,
                                    maxBoxSize: '4'
                                });
                            });
                            
                            if (missionData.commodities.length > 0) {
                                allMissions.push(missionData);
                                console.log(`  ‚úì Imported mission ${index + 1}: ${missionData.payout}, ${missionData.commodities.length} rows`);
                            }
                        } else {
                            console.log(`  ‚ö†Ô∏è No rawText for mission ${index + 1}, skipping`);
                        }
                    });
                    
                    if (allMissions.length === 0) {
                        alert('No valid missions found in JSON file.');
                        return;
                    }
                    
                    // Save to localStorage for import to Hauler Helper
                    const importData = {
                        missions: allMissions,
                        timestamp: Date.now()
                    };
                    
                    localStorage.setItem('haulerHelperOCRImport', JSON.stringify(importData));
                    console.log('üì§ Saved to localStorage:', importData);
                    console.log(`‚úÖ Ready to import ${allMissions.length} missions!`);
                    
                    // Update button
                    const btn = document.getElementById('importJsonBtn');
                    btn.textContent = `‚úì ${allMissions.length} Missions Ready!`;
                    btn.style.backgroundColor = 'var(--color-success)';
                    
                    // Auto-navigate to Hauler Helper
                    setTimeout(() => {
                        window.location.href = 'index.html';
                    }, 1000);
                    
                } catch (error) {
                    console.error('‚ùå Error parsing JSON:', error);
                    alert('Error reading JSON file: ' + error.message);
                }
            };
            
            reader.readAsText(file);
            
            // Reset file input so the same file can be selected again
            event.target.value = '';
        }

        function updateStats() {
            const totalWords = processedResults.reduce((sum, r) => 
                sum + (r.text.trim().split(/\s+/).filter(w => w.length > 0).length), 0
            );
            const totalChars = processedResults.reduce((sum, r) => 
                sum + r.text.length, 0
            );
            
            document.getElementById('totalImages').textContent = selectedFiles.length;
            document.getElementById('totalWords').textContent = totalWords.toLocaleString();
            document.getElementById('totalChars').textContent = totalChars.toLocaleString();
            stats.style.display = 'grid';
        }

        // Import All button
        const importAllBtn = document.getElementById('importAllBtn');
        importAllBtn.addEventListener('click', importAllToHauler);

        // Export functions
        exportJsonBtn.addEventListener('click', () => {
            const aggregateData = aggregateUniqueValues(processedResults);
            
            const exportData = {
                summary: {
                    totalMissions: processedResults.length,
                    uniqueCommodities: aggregateData.commodities,
                    uniqueLocations: aggregateData.allLocations,
                    uniquePayouts: aggregateData.payouts
                },
                missions: processedResults.map(result => {
                    const parsed = result.parsedData || parseStarCitizenMission(result.text);
                    return {
                        filename: result.filename,
                        region: result.region,
                        payout: parsed.payout,
                        segments: parsed.segments,
                        rawText: result.text
                    };
                })
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'star-citizen-missions-ocr.json';
            a.click();
            URL.revokeObjectURL(url);
        });

        exportCsvBtn.addEventListener('click', () => {
            const rows = [['Filename', 'Region', 'Payout', 'Total SCU', 'Commodities', 'Locations']];
            
            processedResults.forEach(result => {
                const parsed = result.parsedData || parseStarCitizenMission(result.text);
                const totalSCU = parsed.segments.reduce((sum, seg) => sum + seg.quantity, 0);
                const commodities = [...new Set(parsed.segments.map(seg => seg.commodity))];
                const locations = [...new Set([
                    ...parsed.segments.map(seg => seg.pickup),
                    ...parsed.segments.map(seg => seg.delivery)
                ])];
                
                rows.push([
                    result.filename,
                    result.region,
                    parsed.payout || '',
                    totalSCU ? totalSCU + ' SCU' : '',
                    commodities.join('; '),
                    locations.join('; ')
                ]);
            });
            
            const csv = rows.map(row => 
                row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(',')
            ).join('\n');
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'star-citizen-missions-ocr.csv';
            a.click();
            URL.revokeObjectURL(url);
        });
    </script>

    <!-- Floating Feedback Button -->
    <button class="feedback-btn-floating" onclick="openFeedbackModal()" title="Send feedback or report a bug">
        <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z" />
        </svg>
        Feedback
    </button>

    <!-- Feedback Modal -->
    <div id="feedbackModal" class="feedback-modal" onclick="if(event.target===this)closeFeedbackModal()">
        <div class="feedback-content">
            <div class="feedback-header">
                <h3>Feedback</h3>
                <button class="feedback-close-btn" onclick="closeFeedbackModal()">
                    <svg width="20" height="20" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            <div class="feedback-body" id="feedbackBody">
                <div class="field-group">
                    <label>Feedback Type</label>
                    <div class="feedback-type-group">
                        <button class="feedback-type-btn active" data-type="bug" onclick="setFeedbackType('bug')">Bug Report</button>
                        <button class="feedback-type-btn" data-type="suggestion" onclick="setFeedbackType('suggestion')">Suggestion</button>
                        <button class="feedback-type-btn" data-type="other" onclick="setFeedbackType('other')">Other</button>
                    </div>
                </div>
                <div class="field-group">
                    <label>Description</label>
                    <textarea id="feedbackDescription" class="feedback-textarea" maxlength="5000"
                        placeholder="Describe the bug. What happened? What did you expect to happen?"
                        oninput="updateFeedbackCharCount()"></textarea>
                    <div id="feedbackCharCount" class="feedback-char-count">Minimum 10 characters (10 more needed)</div>
                </div>
                <div class="field-group">
                    <label>Email <span class="optional">(optional, for follow-up)</span></label>
                    <input type="email" id="feedbackEmail" class="feedback-email-input" placeholder="you@example.com">
                </div>
                <div class="field-group">
                    <div class="feedback-context">
                        <div class="context-label">The following info will be included with your report:</div>
                        <div class="context-detail" id="feedbackContext">Loading...</div>
                    </div>
                </div>
                <div id="feedbackError" class="feedback-error" style="display:none;"></div>
                <div id="feedbackSuccess" class="feedback-success" style="display:none;">
                    <p>Thank you!</p>
                    <p class="sub">Your feedback has been sent.</p>
                </div>
            </div>
            <div class="feedback-footer" id="feedbackFooter">
                <button class="feedback-btn-cancel" onclick="closeFeedbackModal()">Cancel</button>
                <button class="feedback-btn-submit" id="feedbackSubmitBtn" onclick="submitFeedback()" disabled>Send Feedback</button>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // FEEDBACK WIDGET (OCR Scanner page)
        // ========================================

        const FEEDBACK_API_URL = 'https://hauler-helper-feedback.wedswoe.workers.dev';

        let currentFeedbackType = 'bug';

        const FEEDBACK_PLACEHOLDERS = {
            bug: 'Describe the bug. What happened? What did you expect to happen?',
            suggestion: 'What feature or improvement would you like to see?',
            other: 'Share your thoughts...'
        };

        function openFeedbackModal() {
            document.getElementById('feedbackModal').classList.add('active');
            updateFeedbackContext();
            updateFeedbackCharCount();
            updateFeedbackSubmitState();
        }

        function closeFeedbackModal() {
            const modal = document.getElementById('feedbackModal');
            modal.classList.remove('active');
            currentFeedbackType = 'bug';
            document.getElementById('feedbackDescription').value = '';
            document.getElementById('feedbackEmail').value = '';
            document.getElementById('feedbackError').style.display = 'none';
            document.getElementById('feedbackSuccess').style.display = 'none';
            document.querySelectorAll('#feedbackBody > .field-group').forEach(el => el.style.display = '');
            document.getElementById('feedbackFooter').style.display = '';
            document.getElementById('feedbackSubmitBtn').textContent = 'Send Feedback';
            document.querySelectorAll('.feedback-type-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.type === 'bug');
            });
            document.getElementById('feedbackDescription').placeholder = FEEDBACK_PLACEHOLDERS.bug;
        }

        function setFeedbackType(type) {
            currentFeedbackType = type;
            document.querySelectorAll('.feedback-type-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.type === type);
            });
            document.getElementById('feedbackDescription').placeholder = FEEDBACK_PLACEHOLDERS[type];
        }

        function updateFeedbackCharCount() {
            const desc = document.getElementById('feedbackDescription').value;
            const countEl = document.getElementById('feedbackCharCount');
            if (desc.length < 10) {
                countEl.textContent = `Minimum 10 characters (${10 - desc.length} more needed)`;
            } else {
                countEl.textContent = `${desc.length}/5000`;
            }
            updateFeedbackSubmitState();
        }

        function updateFeedbackSubmitState() {
            const desc = document.getElementById('feedbackDescription').value.trim();
            const btn = document.getElementById('feedbackSubmitBtn');
            btn.disabled = desc.length < 10;
        }

        function getFeedbackContext() {
            const processedCount = document.querySelectorAll('.result-card').length;
            return {
                page: 'OCR Scanner',
                processedImages: processedCount,
                theme: document.body.dataset.theme || 'stardust'
            };
        }

        function updateFeedbackContext() {
            const ctx = getFeedbackContext();
            const el = document.getElementById('feedbackContext');
            el.innerHTML =
                `<span>Page:</span> ${ctx.page}<br>` +
                `<span>Processed images:</span> ${ctx.processedImages}<br>` +
                `<span>Theme:</span> ${ctx.theme}`;
        }

        async function submitFeedback() {
            const desc = document.getElementById('feedbackDescription').value.trim();
            if (desc.length < 10) return;

            const submitBtn = document.getElementById('feedbackSubmitBtn');
            const errorEl = document.getElementById('feedbackError');
            submitBtn.disabled = true;
            submitBtn.textContent = 'Sending...';
            errorEl.style.display = 'none';

            const payload = {
                type: currentFeedbackType,
                description: desc,
                email: document.getElementById('feedbackEmail').value.trim() || undefined,
                appContext: getFeedbackContext(),
                userAgent: navigator.userAgent,
                timestamp: new Date().toISOString()
            };

            try {
                const response = await fetch(FEEDBACK_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (response.ok) {
                    document.querySelectorAll('#feedbackBody > .field-group').forEach(el => el.style.display = 'none');
                    document.getElementById('feedbackSuccess').style.display = '';
                    document.getElementById('feedbackFooter').style.display = 'none';
                    setTimeout(() => closeFeedbackModal(), 2000);
                } else {
                    const data = await response.json().catch(() => ({}));
                    errorEl.textContent = data.error || 'Failed to send feedback. Please try again.';
                    errorEl.style.display = 'block';
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Send Feedback';
                }
            } catch {
                errorEl.textContent = 'Network error. Please check your connection and try again.';
                errorEl.style.display = 'block';
                submitBtn.disabled = false;
                submitBtn.textContent = 'Send Feedback';
            }
        }
    </script>
</body>
</html>
