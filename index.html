<!DOC

                TYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hauler Helper - Star Citizen</title>
    <link rel="stylesheet" href="css/themes.css">
    <link rel="stylesheet" href="css/main.css">
</head>
<body data-theme="stardust">
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>HAULER HELPER</h1>
            <div class="subtitle">Your Ship Manifest for Star Citizen</div>
            <div style="font-weight: bold; color: var(--color-warning); font-size: 11px; margin-top: 10px; letter-spacing: 1px;">
                THIS IS A WORK IN PROGRESS, EXPECT BUGS AND MISSING/INCORRECT INFORMATION
            </div>
        </div>
        
        <!-- Decorative gradient line -->
        <div style="width: 100%; height: 2px; margin: 25px 0 30px 0; background: linear-gradient(90deg, transparent 0%, var(--color-primary) 50%, transparent 100%);"></div>
       
        <!-- Navigation -->
        <div class="nav-bar">
            <a href="index.html" class="nav-link active">Mission Planner</a>
            <a href="ocr-scanner.html" class="nav-link">OCR Scanner (experimental)</a>
        </div>
        
        <!-- Controls -->
        <div class="controls">
            <div class="control-group">
                <label>Ship</label>
                <input type="text" id="shipSelect" list="shipList" placeholder="Search or select ship..." onchange="updateShip()" autocomplete="off">
                <datalist id="shipList">
                </datalist>
            </div>
            <div class="control-group">
                <label>System</label>
                <select id="systemSelect" onchange="updateSystem()">
                    <option value="">Select System</option>
                    <option value="microtech">microTech</option>
                    <option value="hurston">Hurston </option>
                    <option value="arccorp">ArcCorp</option>
                    <option value="crusader">Crusader</option>
                    <option value="nyx">Nyx</option>
                    <option value="pyro" disabled>Pyro (Coming Soon)</option>
                </select>
            </div>
            <div class="control-group">
                <label>Mission Category</label>
                <select id="categorySelect" onchange="updateCategory()">
                    <option value="">Select Category</option>
                    <option value="planetary">Planetary</option>
                    <option value="local">Local</option>
                    <option value="stellar">Stellar</option>
                    <option value="interstellar">Interstellar</option>
                </select>
            </div>
            <div class="control-group">
                <label>Theme</label>
                <select id="themeSelect" onchange="changeTheme()">
                    <option value="stardust">Stardust</option>
                    <option value="lux">Lux</option>
                    <option value="pulse">Pulse</option>
                    <option value="flow">Flow</option>
                    <option value="dark">Dark</option>
                    <option value="cetacean">Cetacean</option>
                    <option value="wednesday">Wednesday</option>
                    <option value="moonshine">Moonshine</option>
                    <option value="cassette">Cassette</option>
                    <option value="cargo-explorer">Cargo Explorer</option>
                </select>
            </div>
        </div>

        <!-- Main Layout -->
        <div class="main-layout">
            <!-- Column 1: Mission Panels -->
            <div class="missions-column">
                <div class="missions-scroll" id="missionsContainer">
                    <!-- Mission panels will be added here -->
                </div>
                <button class="btn-add-mission" onclick="addMissionPanel()">+ Add Mission</button>
            </div>

            <!-- Column 2: Delivery Manager -->
            <div class="delivery-summary">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2>Delivery Manager</h2>
                </div>
                
                <!-- Tab Navigation -->
                <div class="delivery-tabs">
                    <button class="tab-button active" onclick="switchDeliveryTab('route')">Route Planner</button>
                    <button class="tab-button" onclick="switchDeliveryTab('grid')">Visualizer</button>
                </div>
                

                <!-- Cargo Grid Tab -->
                <div id="gridTab" class="tab-content" style="display: none;">
                    <div class="grid-layout-selector">
                        <span style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 1px;">Columns:</span>
                        <select id="gridColumns" onchange="updateGridLayout()" style="background-color: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); padding: 6px 10px; border-radius: 4px; font-size: 12px;">
                            <option value="1">1</option>
                            <option value="2">2</option>
                            <option value="3" selected>3</option>
                            <option value="4">4</option>
                        </select>
                        <span style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 1px; margin-left: 15px;">Rows:</span>
                        <select id="gridRows" onchange="updateGridLayout()" style="background-color: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); padding: 6px 10px; border-radius: 4px; font-size: 12px;">
                            <option value="1">1</option>
                            <option value="2">2</option>
                            <option value="3" selected>3</option>
                            <option value="4">4</option>
                            <option value="5">5</option>
                            <option value="6">6</option>
                            <option value="7">7</option>
                            <option value="8">8</option>
                            <option value="9">9</option>
                            <option value="10">10</option>
                        </select>
                    </div>
                    <div id="cargoGrid" class="cargo-grid-container layout-2x1">
                        <div class="empty-state">No cargo groups to display</div>
                    </div>
                </div>
                
                <!-- Route Planner Tab -->
                <div id="routeTab" class="tab-content" style="display: block;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <span style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 1px;">View:</span>
                        <select id="routeViewModeSelect" onchange="changeRouteViewMode(this.value)" style="background-color: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); padding: 6px 10px; border-radius: 4px; font-size: 12px;">
                            <option value="all">Show All Steps</option>
                            <option value="current">Current Step Only</option>
                            <option value="current-next">Current + Next Step</option>
                        </select>
                    </div>
                    <button onclick="resetRouteCompletion()" style="background-color: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-secondary); padding: 6px 12px; border-radius: 4px; font-size: 11px; cursor: pointer; text-transform: uppercase; letter-spacing: 1px;">
                        Reset Completion
                    </button>
                </div>
                <div id="routePlanner">
                        <div class="empty-state">No route planned</div>
                    </div>
                </div>
            </div>

            <!-- Column 3: Stats -->
            <div class="stats-column">
                <div class="stat-panel">
                    <div class="stat-label">Total Payout</div>
                    <div class="stat-value" id="totalPayout">0K</div>
                </div>
                <div class="stat-panel">
                    <div class="stat-label">SCU Total</div>
                    <div class="stat-value" id="scuTotal">0</div>
                    <div class="capacity-meter">
                        <div class="capacity-bar">
                            <div class="capacity-fill" id="capacityFill" style="width: 0%"></div>
                        </div>
                        <div class="capacity-text" id="capacityText">0 / 0 SCU</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Color Picker Modal -->
    <div class="color-picker-modal" id="colorPickerModal">
        <div class="color-picker-content">
            <div class="color-picker-title">Choose Marker Color</div>
            <div class="color-palette theme-colors" id="colorPalette">
                <!-- Colors will be populated dynamically -->
            </div>
            <input type="color" class="custom-color-input" id="customColorInput">
            <div class="color-picker-buttons">
                <button class="btn-color-picker btn-cancel" onclick="closeColorPicker()">Cancel</button>
                <button class="btn-color-picker btn-confirm" onclick="confirmColor()">Confirm</button>
            </div>
        </div>
    </div>

    <script src="js/data/theme-colors.js?v=20250106"></script>
    <script src="js/data/ships.js?v=20250106"></script>
    <script src="js/data/locations.js?v=20250106"></script>
    <script src="js/data/commodities.js?v=20250106"></script>
    <script src="js/data/payouts.js?v=20250106"></script>
    <script src="js/data/autofill-patterns.js?v=20250106"></script>
    
    <script>
        // Data
        let missionCounter = 0;
        let selectedShip = null;
        let selectedSystem = null;
        let selectedCategory = null;
        let missions = [];
        let locationColors = {};
        let deliveryOrder = []; // Track custom order of delivery locations
        let commodityOrder = []; // Track custom order of commodities
        let cargoGridLayout = '2x1'; // Track cargo grid layout
        let cargoGridOrder = []; // Track custom order of groups in cargo grid
        let cargoGroups = {}; // Store cargo groups for persistent colors/labels
        let currentColorTarget = null;
        let routeStepCompletion = {}; // Track which route steps are completed
        let routeViewMode = 'all'; // 'all', 'current', 'current-next'
        let isLoadingSession = false;  // â† ADD THIS LINE

        // Theme color palettes (loaded from external file)
        const themeColorPalettes = window.THEME_COLOR_PALETTES || {};

        // Ships database (sorted alphabetically by name)
        const ships = window.SHIPS_DATABASE || [];

        // Locations database (sorted alphabetically)
        const locations = window.LOCATIONS_DATABASE || {};

        // Commodities database (sorted alphabetically)
        const commodities = window.COMMODITIES_DATABASE || {};

        // Payouts database (sorted numerically low to high)
        const payouts = window.PAYOUTS_DATABASE || {};


        // Load cargo grid expanded state
        function loadCargoGridExpandedState() {
            const saved = localStorage.getItem('haulerHelperCargoGridExpanded');
            if (saved === 'true') {
                cargoGridExpanded = true;
            }
        }

        // Initialize
        function init() {
            console.log('%cðŸŽ¯ HAULER HELPER v3.3.6 - WAREHOUSE LOGIC FIX', 'background: #4dd4ac; color: #000; font-size: 16px; padding: 8px;');

            // HANDLE dragstart at document level (since addEventListener on cards doesn't work)
            document.addEventListener('dragstart', function(e) {
                // Check if it's a cargo card
                if (e.target.classList && e.target.classList.contains('cargo-group-card')) {
                    handleCargoGridDragStart(e);
                }
            }, true); // Use capture phase
            
            document.addEventListener('dragend', function(e) {
                if (e.target.classList && e.target.classList.contains('cargo-group-card')) {
                    handleCargoGridDragEnd(e);
                }
            }, true);
            
            document.addEventListener('dragover', function(e) {
                if ((e.target.classList && e.target.classList.contains('cargo-group-card')) ||
                    (e.target.classList && e.target.classList.contains('empty-cell'))) {
                    handleCargoGridDragOver(e);
                }
            }, true);
            
            document.addEventListener('drop', function(e) {
                if ((e.target.classList && e.target.classList.contains('cargo-group-card')) ||
                    (e.target.classList && e.target.classList.contains('empty-cell'))) {
                    handleCargoGridDrop(e);
                }
            }, true);
            
            // Route stop drag handlers
            document.addEventListener('dragstart', function(e) {
                if (e.target.classList && e.target.classList.contains('route-stop')) {
                    handleRouteStopDragStart(e);
                }
            }, true);
            
            document.addEventListener('dragend', function(e) {
                if (e.target.classList && e.target.classList.contains('route-stop')) {
                    handleRouteStopDragEnd(e);
                }
            }, true);
            
            document.addEventListener('dragover', function(e) {
                if (e.target.closest && e.target.closest('.route-stop')) {
                    handleRouteStopDragOver(e);
                }
            }, true);
            
            document.addEventListener('drop', function(e) {
                if (e.target.closest && e.target.closest('.route-stop')) {
                    handleRouteStopDrop(e);
                }
            }, true);
            


            populateShipSelect();
            loadSession();
            loadTheme();
            loadDeliveryLayout();
            loadDeliveryOrder();
            loadCommodityOrder();
            loadCargoGridLayout();
            loadRouteViewMode();
            updateColorPalette();
            checkForOCRImport();
            checkForOCRImportAll();
        }

        // Check for OCR Scanner import data
        // Helper: Match abbreviated location to full database name

        function matchLocation(ocrName, system, category) {

            if (!ocrName || !system || !category) return '';

            

            // Get locations for this system/category

            const systemData = LOCATIONS_DATABASE[system];

            if (!systemData || !systemData[category]) return ocrName;

            

            const locations = systemData[category];

            

            // Try exact match first

            if (locations.includes(ocrName)) {

                return ocrName;

            }

            
            // === PREPROCESSING: Normalize OCR errors ===
            let normalized = ocrName;
            
            // Fix common OCR character confusions
            normalized = normalized
                .replace(/\bSM0-/g, 'SMO-')        // SM0 (zero) â†’ SMO (letter O)
                .replace(/\bSMo-/g, 'SMO-')        // SMo â†’ SMO
                .replace(/\bSMc-/g, 'SMC-')        // SMc â†’ SMC
                .replace(/\bSMca-/g, 'SMCa-')      // SMca â†’ SMCa
                .replace(/\bS4DC0/g, 'S4DC')       // S4DC0 (zero) â†’ S4DC
                .replace(/\bS4DCO/g, 'S4DC')       // S4DCO (letter O) â†’ S4DC
                .replace(/\bl1\b/gi, 'L1')         // l1 â†’ L1
                .replace(/\bl2\b/gi, 'L2')         // l2 â†’ L2
                .replace(/\bl3\b/gi, 'L3')         // l3 â†’ L3
                .replace(/\bl4\b/gi, 'L4')         // l4 â†’ L4
                .replace(/\bl5\b/gi, 'L5');        // l5 â†’ L5
            
            // Try exact match on normalized
            if (locations.includes(normalized)) {
                return normalized;
            }
            
            // === FACILITY CODE EXTRACTION ===
            // Extract codes like "SMO-13", "S4DC05", "SMCa-6" from longer names
            const codePatterns = [
                /\b(SMO-\d+)\b/i,           // SMO-13, SMO-10, etc.
                /\b(SMC[a-z]?-\d+)\b/i,     // SMCa-6, SMC-8, etc.
                /\b(S4DC\d+)\b/i,           // S4DC05, S4DC10, etc.
                /\b(S4LD\d+)\b/i,           // S4LD01, S4LD13, etc.
                /\b(MT\s*L\d+)\b/i,         // MT L1, MT L2, etc.
                /\b([A-Z]{3}-L\d+)\b/i,     // ARC-L1, CRU-L4, MIC-L2, etc.
                /\b(Cry-Astro\s+\d+-\d+)\b/i, // Cry-Astro 19-02
                /\b(Rayari\s+\w+)\b/i,      // Rayari Anvik, etc.
            ];
            
            for (const pattern of codePatterns) {
                const match = normalized.match(pattern);
                if (match) {
                    const code = match[1].trim();
                    
                    // Try exact match on extracted code
                    const exactCode = locations.find(loc => 
                        loc.toLowerCase() === code.toLowerCase()
                    );
                    if (exactCode) return exactCode;
                    
                    // Try to find location containing this code
                    const containsCode = locations.find(loc =>
                        loc.toLowerCase().includes(code.toLowerCase())
                    );
                    if (containsCode) return containsCode;
                }
            }

            // === CLEANUP: Remove verbose parts ===
            let cleaned = normalized
                .replace(/\b(Mining Facility|Distribution Center|Complex|Depot|Logistics)\b/gi, '')
                .replace(/\b(Harbor|Station|Point)\b/gi, '')
                .replace(/\b(above|at|on)\s+\w+$/gi, '')
                .replace(/\s+/g, ' ')
                .trim();

            // Try exact match on cleaned
            const exactCleaned = locations.find(loc => 
                loc.toLowerCase() === cleaned.toLowerCase()
            );
            if (exactCleaned) return exactCleaned;
            
            // === BIDIRECTIONAL FUZZY MATCHING ===
            const match = locations.find(loc => {
                const locLower = loc.toLowerCase();
                const ocrLower = ocrName.toLowerCase();
                const normLower = normalized.toLowerCase();
                const cleanLower = cleaned.toLowerCase();
                
                return (
                    // OCR name contains database location
                    ocrLower.includes(locLower) ||
                    normLower.includes(locLower) ||
                    cleanLower.includes(locLower) ||
                    // Database location contains OCR name
                    locLower.includes(ocrLower) ||
                    locLower.includes(normLower) ||
                    locLower.includes(cleanLower) ||
                    // Starts with matching
                    loc.startsWith(ocrName) ||
                    ocrName.startsWith(loc) ||
                    loc.startsWith(normalized) ||
                    normalized.startsWith(loc) ||
                    loc.startsWith(cleaned) ||
                    cleaned.startsWith(loc)
                );
            });

            

            return match || ocrName;

        }

        // Helper: Match payout to database format and find closest
        function matchPayout(payoutNumber, system, category) {
            if (!payoutNumber || !system || !category) return '';
            
            // Convert number to "k" format (40750 â†’ "40.75k")
            let payoutK = payoutNumber / 1000;
            
            // Get payouts for this system/category
            const systemData = PAYOUTS_DATABASE[system];
            if (!systemData || !systemData[category]) return '';
            
            const payouts = systemData[category];
            
            // Try to find exact or closest match
            let bestMatch = '';
            let smallestDiff = Infinity;
            
            for (const payout of payouts) {
                // Parse payout string "40.75k" â†’ 40.75
                const value = parseFloat(payout.replace('k', ''));
                const diff = Math.abs(value - payoutK);
                
                if (diff < smallestDiff) {
                    smallestDiff = diff;
                    bestMatch = payout;
                }
                
                // If exact match, stop  
                if (diff < 0.1) break;
            }
            
            return bestMatch;
        }



        function checkForOCRImport() {
            const importData = localStorage.getItem('haulerHelperOCRImport');
            if (!importData) return;
            
            try {
                const data = JSON.parse(importData);
                    console.log('ðŸ“¥ OCR Import detected:', data);

                    // Clear the import flag immediately
                    localStorage.removeItem('haulerHelperOCRImport');

                    // Extract mission data from the first mission
                    const missionData = data.missions && data.missions[0] ? data.missions[0] : data;

                    // Add a new mission with the imported data
                    addMissionPanel();

                    // Get the newly created mission
                    const lastMission = missions[missions.length - 1];

                    // Set payout if available
                    if (missionData.payout) {
                        // Match payout to database format
                        const matchedPayout = matchPayout(missionData.payout, selectedSystem, selectedCategory);
                        console.log('ðŸ’° Payout matching:', missionData.payout, 'â†’', matchedPayout);
                    
                    if (matchedPayout) {
                        lastMission.payout = matchedPayout;
                        const missionPanel = document.getElementById(lastMission.id);
                        const payoutSelect = missionPanel.querySelector('select');
                        if (payoutSelect) {
                            payoutSelect.value = matchedPayout;
                        }
                    }
                }
                
                    // Add commodities
                        if (missionData.commodities && missionData.commodities.length > 0) {
                            // Remove the default empty commodity row
                            if (lastMission.commodities.length > 0) {
                                const firstCommodityId = lastMission.commodities[0].id;
                                removeCommodityRow(lastMission.id, firstCommodityId);
                            }
                            
                            // Add each imported commodity
                            missionData.commodities.forEach((commodity, index) => {
                        if (commodity.commodity || commodity.pickup || commodity.destination) {
                            addCommodityRow(lastMission.id);
                            const commodityId = `${lastMission.id}_commodity_${index}`;
                            const commodityData = lastMission.commodities[index];
                            
                            // Match locations to database names
                            const matchedPickup = matchLocation(commodity.pickup, selectedSystem, selectedCategory);
                            const matchedDestination = matchLocation(commodity.destination, selectedSystem, selectedCategory);
                            
                            // Update the commodity data
                            Object.assign(commodityData, {
                                commodity: commodity.commodity || '',
                                pickup: matchedPickup || '',
                                destination: matchedDestination || '',
                                quantity: commodity.quantity || '',
                                maxBoxSize: commodity.maxBoxSize || '4'
                            });
                            
                            // Update the UI with matched locations
                            const row = document.getElementById(commodityId);
                            if (row) {
                                const selects = row.querySelectorAll('select');
                                const input = row.querySelector('input[type="number"]');
                                if (selects[0]) selects[0].value = matchedPickup || '';
                                if (selects[1]) selects[1].value = commodity.commodity || '';
                                if (input) input.value = commodity.quantity || '';
                                if (selects[2]) selects[2].value = commodity.maxBoxSize || '4';
                                if (selects[3]) selects[3].value = matchedDestination || '';
                            }
                        }
                    });
                }
                
                generateCargoGrid();
                generateRoutePlan();
                updateStats();
                saveSession();
                
                // Show success message
                setTimeout(() => {
                    //alert('âœ… Mission data imported from OCR Scanner!');
                }, 500);
                
            } catch (e) {
                console.error('Error importing OCR data:', e);
                localStorage.removeItem('haulerHelperOCRImport');
            }
        }

        // Check for batch OCR import (Import All)
        function checkForOCRImportAll() {
            const importData = localStorage.getItem('haulerHelperOCRImportAll');
            if (!importData) return;
            
            try {
                const data = JSON.parse(importData);
                console.log('ðŸ“¦ OCR Batch Import detected:', data.missions?.length, 'missions');
                
                // Clear the import flag immediately
                localStorage.removeItem('haulerHelperOCRImportAll');
                
                if (!data.missions || data.missions.length === 0) {
                    console.warn('No missions in batch import data');
                    return;
                }
                
                // Import each mission
                let successCount = 0;
                data.missions.forEach((missionData, missionIndex) => {
                    try {
                        // Add a new mission panel
                        addMissionPanel();
                        const lastMission = missions[missions.length - 1];
                        
                        // Set payout if available
                        if (missionData.payout) {
                            const matchedPayout = matchPayout(missionData.payout, selectedSystem, selectedCategory);
                            console.log(`ðŸ’° Mission ${missionIndex + 1} payout:`, missionData.payout, 'â†’', matchedPayout);
                            
                            if (matchedPayout) {
                                lastMission.payout = matchedPayout;
                                const missionPanel = document.getElementById(lastMission.id);
                                const payoutSelect = missionPanel.querySelector('select');
                                if (payoutSelect) {
                                    payoutSelect.value = matchedPayout;
                                }
                            }
                        }
                        
                        // Add commodities
                        if (missionData.commodities && missionData.commodities.length > 0) {
                            // Remove the default empty commodity row
                            if (lastMission.commodities.length > 0) {
                                const firstCommodityId = lastMission.commodities[0].id;
                                removeCommodityRow(lastMission.id, firstCommodityId);
                            }
                            
                            // Add each imported commodity
                            missionData.commodities.forEach((commodity, index) => {
                                if (commodity.commodity || commodity.pickup || commodity.destination) {
                                    addCommodityRow(lastMission.id);
                                    const commodityId = `${lastMission.id}_commodity_${index}`;
                                    const commodityData = lastMission.commodities[index];
                                    
                                    // Match locations to database names
                                    const matchedPickup = matchLocation(commodity.pickup, selectedSystem, selectedCategory);
                                    const matchedDestination = matchLocation(commodity.destination, selectedSystem, selectedCategory);
                                    
                                    console.log(`ðŸ“ Mission ${missionIndex + 1}, Commodity ${index + 1}:`, 
                                        commodity.pickup, 'â†’', matchedPickup,
                                        '|', commodity.destination, 'â†’', matchedDestination);
                                    
                                    // Update the commodity data
                                    Object.assign(commodityData, {
                                        commodity: commodity.commodity || '',
                                        pickup: matchedPickup || '',
                                        destination: matchedDestination || '',
                                        quantity: commodity.quantity || '',
                                        maxBoxSize: commodity.maxBoxSize || '4'
                                    });
                                    
                                    // Update the UI with matched locations
                                    const row = document.getElementById(commodityId);
                                    if (row) {
                                        const selects = row.querySelectorAll('select');
                                        const input = row.querySelector('input[type="number"]');
                                        if (selects[0]) selects[0].value = matchedPickup || '';
                                        if (selects[1]) selects[1].value = commodity.commodity || '';
                                        if (input) input.value = commodity.quantity || '';
                                        if (selects[2]) selects[2].value = commodity.maxBoxSize || '4';
                                        if (selects[3]) selects[3].value = matchedDestination || '';
                                    }
                                }
                            });
                        }
                        
                        successCount++;
                    } catch (e) {
                        console.error(`Error importing mission ${missionIndex + 1}:`, e);
                    }
                });
                
                generateCargoGrid();
                generateRoutePlan();
                updateStats();
                saveSession();
                
                // Show success message
                setTimeout(() => {
                    //alert(`âœ… ${successCount} mission${successCount !== 1 ? 's' : ''} imported from OCR Scanner!`);
                }, 500);
                
            } catch (e) {
                console.error('Error importing batch OCR data:', e);
                localStorage.removeItem('haulerHelperOCRImportAll');
            }
        }

        // Load delivery layout preference (removed - tabs removed)
        function loadDeliveryLayout() {
            // Function removed - By Location and By Commodity tabs removed
        }

        // Populate ship select
        function populateShipSelect() {
            const datalist = document.getElementById('shipList');
            datalist.innerHTML = '';
            ships.forEach(ship => {
                const option = document.createElement('option');
                option.value = ship.name;
                option.setAttribute('data-id', ship.id);
                datalist.appendChild(option);
            });
        }

        // Update ship
        function updateShip() {
            const input = document.getElementById('shipSelect');
            const selectedName = input.value;
            
            // Find ship by name
            const ship = ships.find(s => s.name === selectedName);
            
            if (ship) {
                selectedShip = ship;
                input.value = ship.name; // Set to full name
            } else {
                selectedShip = null;
                input.value = ''; // Clear invalid input
            }
            
            updateStats();
            saveSession();
        }

        // Update system
        function updateSystem() {
            selectedSystem = document.getElementById('systemSelect').value;
            
            // Update category dropdown based on system rules
            const categorySelect = document.getElementById('categorySelect');
            const localOption = categorySelect.querySelector('option[value="local"]');
            const planetaryOption = categorySelect.querySelector('option[value="planetary"]');
            const stellarOption = categorySelect.querySelector('option[value="stellar"]');
            const interstellarOption = categorySelect.querySelector('option[value="interstellar"]');
            
            // Reset all options
            if (localOption) localOption.disabled = false;
            if (planetaryOption) planetaryOption.disabled = false;
            if (stellarOption) stellarOption.disabled = false;
            if (interstellarOption) interstellarOption.disabled = false;
            
            // Apply system-specific rules
            if (selectedSystem === 'arccorp' || selectedSystem === 'crusader') {
                // No Local missions for ArcCorp and Crusader
                if (localOption) localOption.disabled = true;
                if (selectedCategory === 'local') {
                    selectedCategory = '';
                    categorySelect.value = '';
                    alert('Local missions are not available for ' + selectedSystem + '. Please select Planetary, Stellar, or Interstellar.');
                }
            } else if (selectedSystem === 'nyx') {
                // Only Interstellar missions for Nyx
                if (localOption) localOption.disabled = true;
                if (planetaryOption) planetaryOption.disabled = true;
                if (stellarOption) stellarOption.disabled = true;
                if (selectedCategory !== 'interstellar') {
                    selectedCategory = '';
                    categorySelect.value = '';
                    alert('Nyx only has Interstellar missions. Please select Interstellar category.');
                }
            }
            
            saveSession();
        }

        // Update category
        function updateCategory() {
            selectedCategory = document.getElementById('categorySelect').value;
            saveSession();
        }

        // Change theme
        function changeTheme() {
            const theme = document.getElementById('themeSelect').value;
            document.body.setAttribute('data-theme', theme);
            localStorage.setItem('haulerHelperTheme', theme);
            updateColorPalette();
        }

        // Toggle delivery organizer layout
        function toggleDeliveryLayout() {
            // const container = document.getElementById('deliverySummary'); // Removed - By Location tab removed
            // const containerCommodity = document.getElementById('deliverySummaryCommodity'); // Removed - By Commodity tab removed
            const icon = document.getElementById('layoutIcon');
            const iconCommodity = document.getElementById('layoutIconCommodity');
            
            if (container.classList.contains('two-column')) {
                container.classList.remove('two-column');
                containerCommodity.classList.remove('two-column');
                icon.textContent = 'âš'; // Single column icon
                iconCommodity.textContent = 'âš';
                localStorage.setItem('haulerHelperDeliveryLayout', 'single');
            } else {
                container.classList.add('two-column');
                containerCommodity.classList.add('two-column');
                icon.textContent = 'â˜°'; // Two column icon
                iconCommodity.textContent = 'â˜°';
                localStorage.setItem('haulerHelperDeliveryLayout', 'two-column');
            }
        }

        // Drag and drop handlers for delivery organizer
        let draggedElement = null;

        function handleDragStart(e) {
            draggedElement = e.target;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.innerHTML);
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            
            // Remove drag-over class from all elements
            document.querySelectorAll('.delivery-location').forEach(el => {
                el.classList.remove('drag-over');
            });
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            return false;
        }


        function handleDragLeave(e) {
            e.target.classList.remove('drag-over');
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            e.preventDefault();

            const dropTarget = e.target.closest('.delivery-location');
            if (draggedElement && dropTarget && draggedElement !== dropTarget) {
                const draggedItem = draggedElement.getAttribute('data-location');
                const targetItem = dropTarget.getAttribute('data-location');
                
                // Determine which order array to use based on current grouping mode
                const orderArray = organizerGroupBy === 'commodity' ? commodityOrder : deliveryOrder;
                
                // Reorder the appropriate array
                const draggedIndex = orderArray.indexOf(draggedItem);
                const targetIndex = orderArray.indexOf(targetItem);
                
                orderArray.splice(draggedIndex, 1);
                orderArray.splice(targetIndex, 0, draggedItem);
                
                // Save order and refresh display
                if (organizerGroupBy === 'commodity') {
                    saveCommodityOrder();
                } else {
                    saveDeliveryOrder();
                }
                // updateDeliverySummary removed
            }

            return false;
        }

        function saveDeliveryOrder() {
            localStorage.setItem('haulerHelperDeliveryOrder', JSON.stringify(deliveryOrder));
        }

        function saveCommodityOrder() {
            localStorage.setItem('haulerHelperCommodityOrder', JSON.stringify(commodityOrder));
        }

        function loadDeliveryOrder() {
            const saved = localStorage.getItem('haulerHelperDeliveryOrder');
            if (saved) {
                try {
                    deliveryOrder = JSON.parse(saved);
                } catch (e) {
                    deliveryOrder = [];
                }
            }
        }

        function loadCommodityOrder() {
            const saved = localStorage.getItem('haulerHelperCommodityOrder');
            if (saved) {
                try {
                    commodityOrder = JSON.parse(saved);
                } catch (e) {
                    commodityOrder = [];
                }
            }
        }



        // Load theme
        function loadTheme() {
            const savedTheme = localStorage.getItem('haulerHelperTheme');
            if (savedTheme) {
                document.body.setAttribute('data-theme', savedTheme);
                document.getElementById('themeSelect').value = savedTheme;
            }
        }

        // Update color palette in picker
        function updateColorPalette() {
            const theme = document.body.getAttribute('data-theme');
            const palette = themeColorPalettes[theme] || themeColorPalettes['stardust'];
            const container = document.getElementById('colorPalette');
            
            container.innerHTML = palette.map(color => 
                `<div class="color-option" style="background-color: ${color}" onclick="selectPresetColor('${color}')"></div>`
            ).join('');
        }

        // Add mission panel
        function addMissionPanel() {
            if (!selectedCategory) {
                alert('Please select a mission category first');
                return;
            }

            missionCounter++;
            const missionId = `mission_${missionCounter}`;
            
            const mission = {
                id: missionId,
                payout: '',
                commodities: []
            };
            
            missions.push(mission);
            
            const container = document.getElementById('missionsContainer');
            const panel = createMissionPanel(missionId, missionCounter);
            container.appendChild(panel);
            
            // Add first commodity row by default
            addCommodityRow(missionId);
            
            saveSession();
        }

        // Create mission panel HTML
        function createMissionPanel(missionId, missionNumber) {
            const panel = document.createElement('div');
            panel.className = 'mission-panel';
            panel.id = missionId;
            
            const system = selectedSystem || 'microtech';
            const category = selectedCategory || 'planetary';
            
            // For interstellar missions, use universal data instead of system-specific
            const isInterstellar = category === 'interstellar';
            const dataSource = isInterstellar ? 'universal' : system;
            
            const categoryLocations = (locations[dataSource] && locations[dataSource][category]) || [];
            const categoryCommodities = (commodities[dataSource] && commodities[dataSource][category]) || [];
            const categoryPayouts = (payouts[dataSource] && payouts[dataSource][category]) || [];
            console.log(`âœ… ${system}.${category} - Found ${categoryPayouts.length} payouts`);
            
            panel.innerHTML = `
                <div class="mission-header">
                    <div class="mission-title">Mission ${missionNumber}</div>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <div class="mission-payout">
                            <label>Payout:</label>
                            <select onchange="updateMissionPayout('${missionId}', this.value)">
                                <option value="">-</option>
                                ${categoryPayouts.map(p => `<option value="${p}">${p}</option>`).join('')}
                            </select>
                        </div>
                        <button class="btn-remove-mission" onclick="removeMissionPanel('${missionId}')">Remove</button>
                    </div>
                </div>
                <div id="${missionId}_commodities"></div>
                <button class="btn-add-commodity" onclick="addCommodityRow('${missionId}')">+ Add Commodity</button>
            `;
            
            return panel;
        }

        // Add commodity row
        function addCommodityRow(missionId) {
            const mission = missions.find(m => m.id === missionId);
            if (mission.commodities.length >= 8) {
                alert('Maximum 8 commodities per mission');
                return;
            }
            
            // Get previous commodity for defaults
            const previousCommodity = mission.commodities[mission.commodities.length - 1];
            
            const commodityId = `${missionId}_commodity_${mission.commodities.length}`;
            mission.commodities.push({
                id: commodityId,
                pickup: previousCommodity?.pickup || '',
                commodity: previousCommodity?.commodity || '',
                quantity: '',
                maxBoxSize: previousCommodity?.maxBoxSize || '4',
                destination: previousCommodity?.destination || ''
            });
            
            const container = document.getElementById(`${missionId}_commodities`);
            const row = createCommodityRow(missionId, commodityId, mission.commodities.length > 1);
            container.appendChild(row);
            
            // Set default values in the new row
            const newCommodity = mission.commodities[mission.commodities.length - 1];
            const selects = row.querySelectorAll('select');
            if (selects[0]) selects[0].value = newCommodity.pickup;
            if (selects[1]) selects[1].value = newCommodity.commodity;
            if (selects[2]) selects[2].value = newCommodity.maxBoxSize;
            if (selects[3]) selects[3].value = newCommodity.destination;
            
            saveSession();
        }

        // Create commodity row HTML
        function createCommodityRow(missionId, commodityId, showRemove) {
            const row = document.createElement('div');
            row.className = 'commodity-row';
            row.id = commodityId;
            
            // Get category-specific locations and commodities
            const system = selectedSystem || 'microtech';
            const category = selectedCategory || 'planetary';
            
            // For interstellar missions, use universal data instead of system-specific
            const isInterstellar = category === 'interstellar';
            const dataSource = isInterstellar ? 'universal' : system;
            
            const categoryLocations = (locations[dataSource] && locations[dataSource][category]) || [];
            const categoryCommodities = (commodities[dataSource] && commodities[dataSource][category]) || [];
            
            row.innerHTML = `
                <select onchange="updateCommodity('${commodityId}', 'pickup', this.value)">
                    <option value="">Pickup Location</option>
                    ${categoryLocations.map(loc => `<option value="${loc}">${loc}</option>`).join('')}
                </select>
                <select onchange="updateCommodity('${commodityId}', 'commodity', this.value)">
                    <option value="">Commodity</option>
                    ${categoryCommodities.map(c => `<option value="${c}">${c}</option>`).join('')}
                </select>
                <input type="number" placeholder="SCU" min="1" onchange="updateCommodity('${commodityId}', 'quantity', this.value)">
                <select onchange="updateCommodity('${commodityId}', 'maxBoxSize', this.value)">
                    <option value="1">Max: 1 SCU</option>
                    <option value="2">Max: 2 SCU</option>
                    <option value="4">Max: 4 SCU</option>
                    <option value="8">Max: 8 SCU</option>
                    <option value="16">Max: 16 SCU</option>
                    <option value="24">Max: 24 SCU</option>
                    <option value="32">Max: 32 SCU</option>
                </select>
                <select onchange="updateCommodity('${commodityId}', 'destination', this.value)">
                    <option value="">Destination</option>
                    ${categoryLocations.map(loc => `<option value="${loc}">${loc}</option>`).join('')}
                </select>
                ${showRemove ? 
                    `<button class="btn-remove-commodity" onclick="removeCommodityRow('${missionId}', '${commodityId}')">-</button>` :
                    `<div></div>`
                }
            `;
            
            return row;
        }

        // Update commodity data
                function updateCommodity(commodityId, field, value) {
            for (const mission of missions) {
                const commodity = mission.commodities.find(c => c.id === commodityId);
                if (commodity) {
                    commodity[field] = value;
                    
                    // AUTO-FILL PATTERNS: If this is the first commodity and we're setting the commodity name
                    const isFirstCommodity = commodity.id.includes('_commodity_0');
                    const isSettingCommodity = field === 'commodity';
                    const hasAutoFillSystem = selectedSystem === 'microtech' || selectedSystem === 'hurston';

            if (isFirstCommodity && isSettingCommodity && value && hasAutoFillSystem) {
                applyAutoFillPattern(mission, value, selectedSystem);
            }
                    
                    break;
                }
            }
            generateRoutePlan();
            generateCargoGrid();
            updateStats();
            saveSession();
        }

        // Update mission payout
        function updateMissionPayout(missionId, payout) {
            const mission = missions.find(m => m.id === missionId);
            if (mission) {
                mission.payout = payout;
            }
            updateStats();
            saveSession();
        }

        // AUTO-FILL HELPER FUNCTION
        function applyAutoFillPattern(mission, firstCommodity, system) {
            // Only apply if mission has exactly 1 commodity (we're setting the first one)
            if (mission.commodities.length !== 1) return;
            
            // Get mission payout
            const missionPayout = mission.payout || '';
            
            // Get patterns from external file
            const { payoutPatterns, commodityPatterns, universalCommoditySequences } = window.AUTOFILL_PATTERNS || {};
            
            if (!payoutPatterns || !commodityPatterns || !universalCommoditySequences) {
                console.error('âŒ Autofill patterns not loaded!');
                return;
            }
            
            let pattern = null;
            let patternType = '';
            
            // Step 1: Check for payout-specific pattern (most specific)
            if (payoutPatterns[system] && 
                payoutPatterns[system][firstCommodity] && 
                payoutPatterns[system][firstCommodity][missionPayout]) {
                pattern = payoutPatterns[system][firstCommodity][missionPayout];
                patternType = 'payout-specific';
                console.log(`âœ… Found payout-specific pattern: ${system} / ${firstCommodity} / ${missionPayout}`);
            }
            
            // Step 2: Check for commodity-only pattern (less specific)
            if (!pattern && commodityPatterns[system] && commodityPatterns[system][firstCommodity]) {
                pattern = commodityPatterns[system][firstCommodity];
                patternType = 'commodity-only';
                console.log(`âœ… Found commodity-only pattern: ${system} / ${firstCommodity}`);
            }
            
            // Step 3: Check for universal commodity sequence
            if (!pattern && universalCommoditySequences[firstCommodity]) {
                pattern = {
                    commodities: universalCommoditySequences[firstCommodity]
                };
                patternType = 'universal-sequence';
                console.log(`âœ… Found universal commodity sequence: ${firstCommodity}`);
            }
            
            if (!pattern) {
                console.log(`âŒ No autofill pattern found`);
                return; // No pattern found
            }
            
            console.log(`âœ¨ Auto-filling ${system} mission with ${firstCommodity} (${patternType} pattern)`);
            
            // Add 3 more commodity rows (we already have 1)
            for (let i = 1; i < 4; i++) {
                if (mission.commodities.length >= 4) break;
                addCommodityRow(mission.id);
            }
            
            // Wait for DOM to update, then fill in values
            setTimeout(() => {
                mission.commodities.forEach((commodity, index) => {
                    // Fill pickups (if pattern specifies them and they're not null)
                    if (pattern.pickups && pattern.pickups[index] !== null && pattern.pickups[index] !== undefined) {
                        commodity.pickup = pattern.pickups[index];
                        const pickupSelect = document.querySelector(`#${commodity.id} select:nth-of-type(1)`);
                        if (pickupSelect) pickupSelect.value = pattern.pickups[index];
                    }
                    
                    // Fill destinations (if pattern specifies them and they're not null)
                    if (pattern.destinations && pattern.destinations[index] !== null && pattern.destinations[index] !== undefined) {
                        commodity.destination = pattern.destinations[index];
                        const destSelect = document.querySelector(`#${commodity.id} select:nth-of-type(4)`);
                        if (destSelect) destSelect.value = pattern.destinations[index];
                    }
                    
                    // Fill commodities (always)
                    if (pattern.commodities && pattern.commodities[index]) {
                        commodity.commodity = pattern.commodities[index];
                        const commoditySelect = document.querySelector(`#${commodity.id} select:nth-of-type(2)`);
                        if (commoditySelect) commoditySelect.value = pattern.commodities[index];
                    }
                });
                
                // Update displays
                generateRoutePlan();
                generateCargoGrid();
                updateStats();
                saveSession();
            }, 100);
        }

        // Remove commodity row
        function removeCommodityRow(missionId, commodityId) {
            const mission = missions.find(m => m.id === missionId);
            if (mission) {
                mission.commodities = mission.commodities.filter(c => c.id !== commodityId);
                document.getElementById(commodityId).remove();
            }
            generateRoutePlan();
            generateCargoGrid();
            updateStats();
            saveSession();
        }

        // Remove mission panel
        function removeMissionPanel(missionId) {
            missions = missions.filter(m => m.id !== missionId);
            document.getElementById(missionId).remove();
            generateRoutePlan();
            generateCargoGrid();
            updateStats();
            saveSession();
        }

        // Get inline SVG icon for box sizes (supports currentColor for theming)
        function getBoxIconSVG(size) {
            const svgs = {
                '1': '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="box-icon-svg"><path fill="currentColor" d="M15.88,7.74v8.52h-7.75V7.74h7.75M16.88,6.74H7.12v10.52h9.75V6.74h0Z"/><path fill="currentColor" d="M12.11,9.15h.9v6.01h-1.3v-4.68l-1.04.26-.27-1.08,1.71-.51Z"/></svg>',
                '2': '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="box-icon-svg"><path fill="currentColor" d="M15.88,3.53v16.94h-7.75V3.53h7.75M16.88,2.53H7.12v18.94h9.75V2.53h0Z"/><path fill="currentColor" d="M10.76,11.21l-.92-.74c.59-.8,1.16-1.24,2.23-1.24,1.27,0,2.06.73,2.06,1.85,0,1-.51,1.5-1.57,2.32l-.97.75h2.6v1.13h-4.42v-1.04l1.99-1.63c.74-.61,1.03-.94,1.03-1.43s-.33-.78-.8-.78-.78.26-1.22.8Z"/></svg>',
                '4': '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="box-icon-svg"><path fill="currentColor" d="M20.49,3.53v16.94H3.51V3.53h16.98M21.49,2.53H2.51v18.94h18.98V2.53h0Z"/><path fill="currentColor" d="M13.55,9.53v3.66h.8v1.07h-.8v1.29h-1.25v-1.29h-2.92l-.21-.93,3.28-3.8h1.11ZM12.3,11.33l-1.59,1.86h1.59v-1.86Z"/></svg>',
                '8': '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="box-icon-svg"><path fill="currentColor" d="M11.15,11.38c0-.37.31-.69.85-.69s.85.33.85.7c0,.43-.33.74-.85.74s-.85-.32-.85-.75Z"/><path fill="currentColor" d="M13.03,13.91c0,.43-.38.75-1.03.75s-1.03-.32-1.03-.75c0-.47.43-.74,1.03-.74s1.03.27,1.03.74Z"/><path fill="currentColor" d="M2.51,2.73v18.94h18.98V2.73H2.51ZM12,15.74c-1.32,0-2.3-.68-2.3-1.73,0-.73.33-1.16.96-1.45-.46-.28-.76-.66-.76-1.31,0-.92.84-1.65,2.1-1.65s2.1.73,2.1,1.65c0,.65-.3,1.03-.76,1.31.6.32.96.7.96,1.42,0,1.12-.98,1.76-2.3,1.76Z"/></svg>',
                '16': '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="box-icon-svg"><path fill="currentColor" d="M13.94,12.76c-.65,0-1.03.36-1.03.87s.39.9,1.04.9,1.03-.37,1.03-.89-.4-.88-1.04-.88Z"/><path fill="currentColor" d="M2.51,2.73v18.94h18.98V2.73H2.51ZM3.72,20.37v-4.71l4.7,4.71H3.72ZM10.33,15.55h-1.3v-4.68l-1.04.26-.27-1.08,1.71-.51h.9v6.01ZM14,15.66c-.77,0-1.3-.23-1.72-.64-.43-.44-.71-1.08-.71-2.27,0-1.85.84-3.27,2.62-3.27.81,0,1.34.24,1.87.66l-.69,1.01c-.39-.3-.71-.48-1.22-.48-.74,0-1.12.6-1.2,1.39.3-.2.64-.39,1.23-.39,1.19,0,2.1.66,2.1,1.91s-.98,2.08-2.28,2.08ZM20.18,8.75l-4.7-4.7h4.7v4.7Z"/></svg>',
                '24': '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="box-icon-svg"><path fill="currentColor" d="M2.51,2.73v18.94h18.98V2.73H2.51ZM12,15.74c-1.32,0-2.3-.68-2.3-1.73,0-.73.33-1.16.96-1.45-.46-.28-.76-.66-.76-1.31,0-.92.84-1.65,2.1-1.65s2.1.73,2.1,1.65c0,.65-.3,1.03-.76,1.31.6.32.96.7.96,1.42,0,1.12-.98,1.76-2.3,1.76Z"/></svg>',
                '32': '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="box-icon-svg"><path fill="currentColor" d="M2.51,2.54v18.94h18.98V2.54H2.51ZM3.84,3.75h4.7l-4.7,4.7V3.75ZM3.77,20.17v-4.7l4.7,4.7H3.77ZM9.34,15.11c-1.07,0-1.81-.43-2.33-1.03l.9-.87c.42.46.83.72,1.44.72.49,0,.85-.28.85-.73,0-.5-.42-.77-1.17-.77h-.55l-.2-.84,1.43-1.43h-2.36v-1.13h4.05v.99l-1.51,1.44c.82.14,1.59.57,1.59,1.69s-.82,1.96-2.14,1.96ZM12.41,13.96l1.98-1.62c.73-.62,1.02-.94,1.02-1.44s-.32-.77-.8-.77c-.45,0-.77.25-1.21.8l-.93-.74c.6-.81,1.17-1.24,2.24-1.24,1.26,0,2.05.73,2.05,1.85,0,1-.52,1.5-1.58,2.32l-.96.75h2.6v1.14h-4.41v-1.05ZM20.16,20.21h-4.7l4.7-4.7v4.7ZM20.23,8.56l-4.7-4.71h4.7v4.71Z"/></svg>'
            };
            return svgs[size] || svgs['4']; // Default to 4 if size not found
        }

        // Calculate box breakdown
        function calculateBoxBreakdown(scu, maxBoxSize = 32) {
            const allBoxSizes = [32, 24, 16, 8, 4, 2, 1];
            const boxSizes = allBoxSizes.filter(size => size <= maxBoxSize);
            const breakdown = {};
            let remaining = scu;
            
            for (const size of boxSizes) {
                const count = Math.floor(remaining / size);
                if (count > 0) {
                    breakdown[size] = count;
                    remaining -= size * count;
                }
            }
            
            return breakdown;
        }

        // Update delivery summary

        // Group deliveries by location

        // Tab switching function
        function switchDeliveryTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.style.display = 'none';
            });
            
            // Remove active class from all buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab and activate button
            if (tabName === 'route') {
                document.getElementById('routeTab').style.display = 'block';
            } else if (tabName === 'grid') {
                document.getElementById('gridTab').style.display = 'block';
            }
            
            // Activate the clicked button
            event.target.classList.add('active');
        }

        // Generate optimized route plan
        // Update cargo grid layout based on columns and rows dropdowns
        function updateGridLayout() {
            const cols = parseInt(document.getElementById('gridColumns').value);
            const rows = parseInt(document.getElementById('gridRows').value);
            
            cargoGridLayout = {cols: cols, rows: rows};
            localStorage.setItem('haulerHelperCargoGridLayout', JSON.stringify(cargoGridLayout));
            
            generateCargoGrid();
        }

        // Load cargo grid layout preference
        function loadCargoGridLayout() {
            const saved = localStorage.getItem('haulerHelperCargoGridLayout');
            if (saved) {
                try {
                    cargoGridLayout = JSON.parse(saved);
                    document.getElementById('gridColumns').value = cargoGridLayout.cols || 3;
                    document.getElementById('gridRows').value = cargoGridLayout.rows || 3;
                } catch (e) {
                    cargoGridLayout = {cols: 3, rows: 3};
                }
            } else {
                cargoGridLayout = {cols: 3, rows: 3};
            }
        }

        // Generate cargo grid with free positioning
        function generateCargoGrid() {
            const container = document.getElementById('cargoGrid');
            
            if (!container) {
                console.error('âŒ cargoGrid container not found!');
                return;
            }
            
            // Get cargo groups from missions - include BOTH destinations AND pickup-only locations
            const groupData = {};
            
            missions.forEach((mission, missionIndex) => {
                mission.commodities.forEach(commodity => {
                    if (!commodity.pickup || !commodity.destination || !commodity.commodity || !commodity.quantity) {
                        return;
                    }
                    
                    const scu = parseInt(commodity.quantity) || 0;
                    const destination = commodity.destination;
                    const pickup = commodity.pickup;
                    
                    // Create group for DESTINATION (delivery location)
                    if (!groupData[destination]) {
                        groupData[destination] = {
                            location: destination,
                            type: 'delivery', // This is a delivery location
                            totalSCU: 0,
                            items: []
                        };
                    }
                    
                    groupData[destination].totalSCU += scu;
                    groupData[destination].items.push({
                        missionNum: missionIndex + 1,
                        commodity: commodity.commodity,
                        scu: scu,
                        pickup: commodity.pickup,
                        maxBoxSize: parseInt(commodity.maxBoxSize) || 4,
                        type: 'delivery' // This item is being delivered here
                    });
                    
                    // Also create group for PICKUP location (if different from destination)
                    if (pickup !== destination) {
                        if (!groupData[pickup]) {
                            groupData[pickup] = {
                                location: pickup,
                                type: 'pickup', // This is a pickup-only location
                                totalSCU: 0,
                                items: []
                            };
                        }
                        
                        // Only add to pickup group if it's not already counted as a delivery
                        groupData[pickup].totalSCU += scu;
                        groupData[pickup].items.push({
                            missionNum: missionIndex + 1,
                            commodity: commodity.commodity,
                            scu: scu,
                            destination: commodity.destination,
                            maxBoxSize: parseInt(commodity.maxBoxSize) || 4,
                            type: 'pickup' // This item is being picked up here
                        });
                    } else {
                        // This location has both pickup and delivery
                        groupData[destination].type = 'both';
                    }
                });
            });
            
            if (Object.keys(groupData).length === 0) {
                container.innerHTML = '<div class="empty-state">No cargo groups to display</div>';
                container.style.gridTemplateColumns = 'repeat(2, 1fr)';
                return;
            }
            
            // Assign colors and labels to groups
            const theme = document.body.getAttribute('data-theme');
            const palette = themeColorPalettes[theme] || themeColorPalettes['stardust'];
            let groupIndex = Object.keys(cargoGroups).length; // Start from existing count
            
            Object.keys(groupData).forEach(location => {
                if (!cargoGroups[location]) {
                    const groupLetter = String.fromCharCode(65 + groupIndex);
                    cargoGroups[location] = {
                        label: groupLetter,
                        color: palette[groupIndex % palette.length],
                        position: null  // Will be set by user
                    };
                    groupIndex++;
                }
            });
            
            // Calculate grid dimensions
            const cols = cargoGridLayout.cols || 3;
            const rows = cargoGridLayout.rows || 3;
            const totalCells = rows * cols;
            
            // Build grid with positioned groups
            container.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            
            // Create array of cells
            const cells = [];
            for (let i = 0; i < totalCells; i++) {
                cells.push({ position: i, group: null });
            }
            
            // Place groups in their positions (or auto-place if no position set)
            let autoPosition = 0;
            Object.keys(groupData).forEach(location => {
                const group = cargoGroups[location];
                const data = groupData[location];
                
                // Use saved position or auto-place
                let position = group.position;
                if (position === null || position === undefined || position >= totalCells) {
                    // Auto-place in next available spot
                    while (autoPosition < totalCells && cells[autoPosition].group !== null) {
                        autoPosition++;
                    }
                    position = autoPosition;
                    group.position = position;
                }
                
                if (position < totalCells) {
                    cells[position].group = {
                        location: location,
                        type: data.type, // 'pickup', 'delivery', or 'both'
                        label: group.label,
                        color: group.color,
                        position: group.position,
                        totalSCU: data.totalSCU,
                        items: data.items  // Explicitly take items from data
                    };
                }
            });
            
            // Render grid
            container.innerHTML = cells.map((cell, index) => {
                if (!cell.group) {
                    // Empty cell - drop target
                    return `
                        <div class="cargo-group-cell empty-cell" 
                             data-position="${index}">
                        </div>
                    `;
                }
                
                const g = cell.group;
                
                // Separate items by type for organized display
                const pickupItems = (g.items || []).filter(item => item.type === 'pickup');
                const deliveryItems = (g.items || []).filter(item => item.type === 'delivery');
                
                return `
                    <div class="cargo-group-card" 
                         data-location="${g.location}"
                         data-type="${g.type}"
                         data-position="${index}"
                         style="border-color: ${g.color}"
                         draggable="true">
                        <div class="cargo-group-header">
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <div class="cargo-drag-handle" title="Drag to reposition">â‹®â‹®</div>
                                <div class="cargo-group-label-edit" 
                                     style="color: ${g.color}; cursor: pointer; pointer-events: auto;"
                                     onclick="event.stopPropagation(); editCargoGroupLabel('${g.location}', event)">
                                    ${g.label}
                                </div>
                            </div>
                            <div class="cargo-group-scu">${g.totalSCU} SCU</div>
                        </div>
                        <div class="cargo-group-color-edit"
                             style="background-color: ${g.color}; width: 30px; height: 30px; border-radius: 4px; cursor: pointer; margin: 8px 0;"
                             onclick="event.stopPropagation(); editCargoGroupColor('${g.location}')">
                        </div>
                        <div class="cargo-group-destination">${g.location}</div>
                        <div class="expand-indicator" onclick="event.stopPropagation(); toggleCargoGroupExpand(this.parentElement)">Click to expand</div>
                        <div class="cargo-group-details">
                            ${pickupItems.length > 0 ? `
                                <div style="margin-bottom: 16px;">
                                    <div style="font-size: 11px; font-weight: 600; color: var(--color-warning); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; border-bottom: 1px solid var(--border-color); padding-bottom: 4px;">
                                        ðŸ“¦ PICKUPS:
                                    </div>
                                    ${pickupItems.map(item => {
                                        const boxes = calculateBoxBreakdown(item.scu, item.maxBoxSize);
                                        return `
                                            <div class="cargo-group-details-item">
                                                <span class="mission-num">Mission ${item.missionNum}:</span>
                                                <span class="commodity">${item.commodity}</span>
                                                <span>(${item.scu} SCU â†’ ${item.destination})</span>
                                            </div>
                                            <div class="box-breakdown" style="padding-left: 10px; margin-bottom: 8px;">
                                                ${Object.entries(boxes).map(([size, count]) => `
                                                    <div class="box-icon">
                                                        ${getBoxIconSVG(size)}
                                                        <span class="box-count">Ã— ${count}</span>
                                                    </div>
                                                `).join('')}
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            ` : ''}
                            ${deliveryItems.length > 0 ? `
                                <div style="margin-bottom: 16px;">
                                    <div style="font-size: 11px; font-weight: 600; color: var(--color-success); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; border-bottom: 1px solid var(--border-color); padding-bottom: 4px;">
                                        ðŸ“­ DROPOFFS:
                                    </div>
                                    ${deliveryItems.map(item => {
                                        const boxes = calculateBoxBreakdown(item.scu, item.maxBoxSize);
                                        return `
                                            <div class="cargo-group-details-item">
                                                <span class="mission-num">Mission ${item.missionNum}:</span>
                                                <span class="commodity">${item.commodity}</span>
                                                <span>(${item.scu} SCU â† ${item.pickup})</span>
                                            </div>
                                            <div class="box-breakdown" style="padding-left: 10px; margin-bottom: 8px;">
                                                ${Object.entries(boxes).map(([size, count]) => `
                                                    <div class="box-icon">
                                                        ${getBoxIconSVG(size)}
                                                        <span class="box-count">Ã— ${count}</span>
                                                    </div>
                                                `).join('')}
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }).join('');
            
            // Attach drag handlers and apply expanded state after rendering
            setTimeout(() => {
                attachCargoGridDragHandlers();
                
                // Apply expanded state to all cards
                if (cargoGridExpanded) {
                    document.querySelectorAll('.cargo-group-card').forEach(card => {
                        card.classList.add('expanded');
                    });
                }
                
                console.log('âœ… Cargo grid rendering complete');
            }, 0);
        }

        // Edit cargo group label
        function editCargoGroupLabel(destination, event) {
            event.stopPropagation();
            const newLabel = prompt('Enter new label for this cargo group:', cargoGroups[destination].label);
            if (newLabel !== null && newLabel.trim() !== '') {
                cargoGroups[destination].label = newLabel.trim();
                generateCargoGrid();
                generateRoutePlan(); // Update route planner too
                saveSession();
            }
        }

        // Edit cargo group color
        function editCargoGroupColor(destination) {
            currentColorTarget = destination;
            const modal = document.getElementById('colorPickerModal');
            modal.classList.add('active');
            
            const currentColor = cargoGroups[destination].color;
            document.getElementById('customColorInput').value = currentColor;
        }




        // DIAGNOSTIC: Check actual DOM state
        window.diagnoseCargoGrid = function() {
            const cards = document.querySelectorAll('.cargo-group-card');
            console.log('=== CARGO GRID DIAGNOSTICS ===');
            console.log('Found cards:', cards.length);
            
            cards.forEach((card, i) => {
                console.log(`Card ${i}:`, {
                    draggable: card.draggable,
                    hasAttribute: card.hasAttribute('draggable'),
                    getAttribute: card.getAttribute('draggable'),
                    ondragstart: card.ondragstart,
                    location: card.getAttribute('data-location'),
                    type: card.getAttribute('data-type'),
                    classList: Array.from(card.classList),
                    computedStyle: {
                        pointerEvents: getComputedStyle(card).pointerEvents,
                        userDrag: getComputedStyle(card).webkitUserDrag || getComputedStyle(card).userDrag
                    }
                });
                
                // Check first child (drag handle)
                const dragHandle = card.querySelector('.cargo-drag-handle');
                if (dragHandle) {
                    console.log('  Drag handle:', {
                        computedStyle: {
                            pointerEvents: getComputedStyle(dragHandle).pointerEvents
                        }
                    });
                }
            });
            
            console.log('=== END DIAGNOSTICS ===');
        };

        // TEST FUNCTION - User can call this from console
        window.testDragStart = function() {
            console.log('ðŸ§ª Testing if handleCargoGridDragStart exists:', typeof handleCargoGridDragStart);
            console.log('ðŸ§ª Testing draggedCargoGroup:', draggedCargoGroup);
            console.log('ðŸ§ª Testing cargoGroups:', cargoGroups);
        };


        // Attach drag handlers to all cargo cards after grid generation
        function attachCargoGridDragHandlers() {
            const cards = document.querySelectorAll('.cargo-group-card');
            
            cards.forEach(card => {
                // Remove any existing handlers first
                card.ondragstart = null;
                card.ondragend = null;
                card.ondragover = null;
                card.ondrop = null;
                
                // Attach new handlers (though document-level handlers will catch them)
                card.addEventListener('dragstart', handleCargoGridDragStart, false);
                card.addEventListener('dragend', handleCargoGridDragEnd, false);
                card.addEventListener('dragover', handleCargoGridDragOver, false);
                card.addEventListener('drop', handleCargoGridDrop, false);
            });
            
            // Also attach to empty cells
            const emptyCells = document.querySelectorAll('.empty-cell');
            
            emptyCells.forEach(cell => {
                cell.ondragover = null;
                cell.ondrop = null;
                cell.addEventListener('dragover', handleCargoGridDragOver, false);
                cell.addEventListener('drop', handleCargoGridDrop, false);
            });
        }

        // Cargo grid drag and drop handlers
        let draggedCargoGroup = null;
        let cargoGridExpanded = false; // Track if cargo grid cards are expanded
        let routeStops = []; // Store current route stops for reordering

        function handleCargoGridDragStart(e) {
            // When called from document listener, use e.target instead of e.currentTarget
            const cardElement = e.currentTarget === document ? e.target : e.currentTarget;
            
            draggedCargoGroup = cardElement.getAttribute('data-location');
            console.log('ðŸ”µ Drag start:', draggedCargoGroup);
            
            if (!draggedCargoGroup) {
                console.log('âŒ No location attribute found!');
                return;
            }
            
            cardElement.style.opacity = '0.5';
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', draggedCargoGroup);
        }

        function handleCargoGridDragEnd(e) {
            const cardElement = e.currentTarget === document ? e.target : e.currentTarget;
            cardElement.style.opacity = '1';
            console.log('ðŸ”´ DRAG END');
        }

        function handleCargoGridDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleCargoGridDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            
            console.log('ðŸŸ¢ DROP EVENT FIRED');
            
            if (!draggedCargoGroup) {
                console.log('âŒ No dragged group!');
                return false;
            }
            
            const target = e.currentTarget === document ? e.target : e.currentTarget;
            const targetPosition = parseInt(target.getAttribute('data-position'));
            const targetLocation = target.getAttribute('data-location');
            
            console.log('ðŸŽ¯ DROP TARGET:', {
                targetPosition,
                targetLocation,
                draggedGroup: draggedCargoGroup,
                draggedPosition: cargoGroups[draggedCargoGroup]?.position
            });
            
            // Get dragged item's current position
            const draggedPosition = cargoGroups[draggedCargoGroup].position;
            
            if (targetLocation && targetLocation !== draggedCargoGroup) {
                // Swap positions with another card
                console.log('ðŸ”„ SWAPPING:', draggedCargoGroup, 'â†”ï¸', targetLocation);
                const temp = cargoGroups[targetLocation].position;
                cargoGroups[targetLocation].position = draggedPosition;
                cargoGroups[draggedCargoGroup].position = targetPosition;
            } else if (!targetLocation) {
                // Drop on empty cell - just move
                console.log('ðŸ“¦ MOVING to empty cell:', targetPosition);
                cargoGroups[draggedCargoGroup].position = targetPosition;
            } else {
                console.log('âš ï¸ Dropped on self, no action');
            }
            
            // Regenerate grid and save
            console.log('â™»ï¸ Regenerating grid...');
            generateCargoGrid();
            saveSession();
            
            draggedCargoGroup = null;
            return false;
        }

        // Toggle cargo group expansion
        function toggleCargoGroupExpand(card) {
            // Toggle the global expanded state
            cargoGridExpanded = !cargoGridExpanded;
            
            // Apply to all cards
            document.querySelectorAll('.cargo-group-card').forEach(c => {
                if (cargoGridExpanded) {
                    c.classList.add('expanded');
                } else {
                    c.classList.remove('expanded');
                }
            });
            
            // Save state
            localStorage.setItem('haulerHelperCargoGridExpanded', cargoGridExpanded);
        }

        // Update confirmColor to handle cargo groups
        function confirmColor() {
            if (currentColorTarget) {
                const color = document.getElementById('customColorInput').value;
                
                // Check if it's a cargo group or location marker
                if (cargoGroups[currentColorTarget]) {
                    cargoGroups[currentColorTarget].color = color;
                    generateCargoGrid();
                    generateRoutePlan(); // Update route planner colors too
                } else if (locationColors[currentColorTarget]) {
                    locationColors[currentColorTarget].color = color;
                    // updateDeliverySummary removed
                }
                
                saveSession();
            }
            closeColorPicker();
        }




        // Route planner drag and drop handlers
        let draggedRouteStop = null;
        
        function handleRouteStopDragStart(e) {
            const stopElement = e.currentTarget === document ? e.target : e.currentTarget;
            draggedRouteStop = parseInt(stopElement.getAttribute('data-stop-index'));
            console.log('ðŸ”µ Dragging route stop:', draggedRouteStop);
            stopElement.style.opacity = '0.5';
            e.dataTransfer.effectAllowed = 'move';
        }
        
        function handleRouteStopDragEnd(e) {
            const stopElement = e.currentTarget === document ? e.target : e.currentTarget;
            stopElement.style.opacity = '1';
            draggedRouteStop = null;
        }
        
        function handleRouteStopDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            return false;
        }
        
        function handleRouteStopDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            e.preventDefault();
            
            if (draggedRouteStop === null) return false;
            
            const targetElement = e.currentTarget === document ? e.target : e.currentTarget;
            const targetStop = targetElement.closest('.route-stop');
            if (!targetStop) return false;
            
            const targetIndex = parseInt(targetStop.getAttribute('data-stop-index'));
            
            if (draggedRouteStop === targetIndex) return false;
            
            console.log('ðŸ”„ Swapping stops:', draggedRouteStop, 'â†”ï¸', targetIndex);
            
            // Swap stops in array
            const temp = routeStops[draggedRouteStop];
            routeStops[draggedRouteStop] = routeStops[targetIndex];
            routeStops[targetIndex] = temp;
            
            // Re-render with new order
            renderRoutePlan(routeStops);
            
            return false;
        }

        
        // =============================================================================
        // ROUTE STEP COMPLETION MANAGEMENT
        // =============================================================================
        
        /**
         * Toggle completion status of a route stop
         */
        function toggleRouteStepCompletion(stopIndex) {
            routeStepCompletion[stopIndex] = !routeStepCompletion[stopIndex];
            generateRoutePlan();
            saveSession();
        }
        
        /**
         * Change route view mode
         */
        function changeRouteViewMode(mode) {
            routeViewMode = mode;
            generateRoutePlan();
            localStorage.setItem('haulerHelperRouteViewMode', mode);
        }
        
        /**
         * Load route view mode preference
         */
        function loadRouteViewMode() {
            const saved = localStorage.getItem('haulerHelperRouteViewMode');
            if (saved) {
                routeViewMode = saved;
                const select = document.getElementById('routeViewModeSelect');
                if (select) select.value = saved;
            }
        }
        
        /**
         * Get current uncompleted step index
         */
        function getCurrentStepIndex(totalSteps) {
            for (let i = 0; i < totalSteps; i++) {
                if (!routeStepCompletion[i]) {
                    return i;
                }

        /**
         * Reset all route completion checkboxes
         */
        function resetRouteCompletion() {
            routeStepCompletion = {};
            generateRoutePlan();
            saveSession();
        }
            }
            return totalSteps - 1; // All completed, show last one
        }
        
function generateRoutePlan() {
            const container = document.getElementById('routePlanner');
            
            console.log('');
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('ðŸš€ STARTING ROUTE GENERATION');
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            
            // Build comprehensive location map
            const locationMap = {}; // { location: { pickups: [], deliveries: [] } }
            
            missions.forEach((mission, missionIndex) => {
                mission.commodities.forEach(commodity => {
                    if (!commodity.pickup || !commodity.destination || !commodity.commodity || !commodity.quantity) {
                        return;
                    }
                    
                    const scu = parseInt(commodity.quantity) || 0;
                    const pickup = commodity.pickup;
                    const destination = commodity.destination;
                    
                    // Initialize location entries
                    if (!locationMap[pickup]) locationMap[pickup] = { pickups: [], deliveries: [] };
                    if (!locationMap[destination]) locationMap[destination] = { pickups: [], deliveries: [] };
                    
                    // Add pickup action
                    locationMap[pickup].pickups.push({
                        missionNum: missionIndex + 1,
                        commodity: commodity.commodity,
                        scu: scu,
                        destination: destination,
                        maxBoxSize: parseInt(commodity.maxBoxSize) || 4,
                        id: `m${missionIndex + 1}-${pickup}-${commodity.commodity}-${destination}` // Unique ID with pickup location
                    });
                    
                    // Add delivery action
                    locationMap[destination].deliveries.push({
                        missionNum: missionIndex + 1,
                        commodity: commodity.commodity,
                        scu: scu,
                        pickup: pickup,
                        id: `m${missionIndex + 1}-${pickup}-${commodity.commodity}-${destination}` // Same ID as pickup
                    });
                });
            });
            
            if (Object.keys(locationMap).length === 0) {
                container.innerHTML = '<div class="empty-state">No route planned</div>';
                console.log('âŒ No locations in map - aborting route generation');
                return;
            }
            
            // DEBUG: Show location map contents
            console.log('ðŸ“‹ LOCATION MAP BUILT:');
            Object.entries(locationMap).forEach(([loc, data]) => {
                const pickupSCU = data.pickups.reduce((s, p) => s + p.scu, 0);
                const deliverySCU = data.deliveries.reduce((s, d) => s + d.scu, 0);
                console.log(`  ${loc}:`);
                if (data.pickups.length > 0) {
                    console.log(`    ðŸ“¦ Pickups: ${pickupSCU} SCU (${data.pickups.length} items)`);
                    data.pickups.forEach(p => {
                        console.log(`       - Mission ${p.missionNum}: ${p.commodity} ${p.scu} SCU â†’ ${p.destination}`);
                    });
                }
                if (data.deliveries.length > 0) {
                    console.log(`    ðŸ“­ Deliveries: ${deliverySCU} SCU (${data.deliveries.length} items)`);
                    data.deliveries.forEach(d => {
                        console.log(`       - Mission ${d.missionNum}: ${d.commodity} ${d.scu} SCU from ${d.pickup}`);
                    });
                }
            });
            console.log('');
            
            // Assign colors to cargo groups (by destination)
            const theme = document.body.getAttribute('data-theme');
            const palette = themeColorPalettes[theme] || themeColorPalettes['stardust'];
            let groupIndex = Object.keys(cargoGroups).length; // Start from existing count
            
            // Assign groups for each destination
            Object.keys(locationMap).forEach(location => {
                if (locationMap[location].pickups.length > 0) {
                    locationMap[location].pickups.forEach(pickup => {
                        if (!cargoGroups[pickup.destination]) {
                            const groupLetter = String.fromCharCode(65 + groupIndex);
                            cargoGroups[pickup.destination] = {
                                label: groupLetter,
                                color: palette[groupIndex % palette.length]
                            };
                            groupIndex++;
                        }
                    });
                }
            });
            
                        // Build optimized route - ENHANCED with route solver fixes
            const stops = [];
            const cargoOnBoard = new Set(); // Track IDs of cargo currently on ship
            const allPickupIds = new Set();
            const allDeliveryIds = new Set();
            
            // Collect all pickup and delivery IDs
            Object.values(locationMap).forEach(loc => {
                loc.pickups.forEach(p => allPickupIds.add(p.id));
                loc.deliveries.forEach(d => allDeliveryIds.add(d.id));
            });
            
            let currentCargo = 0;
            const shipCapacity = selectedShip ? selectedShip.capacity : 999999;
            
            // FIX: Identify primary warehouse as location with BOTH pickups AND deliveries
            // Warehouse = distribution hub with cargo going to MANY destinations
            const warehouseLocations = Object.entries(locationMap)
                .filter(([loc, data]) => 
                    data.pickups.length > 0 && 
                    data.deliveries.length > 0
                );
            
            // Sort by: 1) distinct destinations, 2) pickup count, 3) pickup SCU
            const primaryWarehouse = warehouseLocations
                .sort((a, b) => {
                    // Count distinct destinations for pickups
                    const aDestinations = new Set(a[1].pickups.map(p => p.destination)).size;
                    const bDestinations = new Set(b[1].pickups.map(p => p.destination)).size;
                    if (aDestinations !== bDestinations) return bDestinations - aDestinations;
                    
                    // If tied, sort by number of pickup items
                    const aPickupCount = a[1].pickups.length;
                    const bPickupCount = b[1].pickups.length;
                    if (aPickupCount !== bPickupCount) return bPickupCount - aPickupCount;
                    
                    // If still tied, sort by pickup SCU
                    const aPickupSCU = a[1].pickups.reduce((s, p) => s + p.scu, 0);
                    const bPickupSCU = b[1].pickups.reduce((s, p) => s + p.scu, 0);
                    return bPickupSCU - aPickupSCU;
                })[0]?.[0];
            
            console.log('ðŸ­ WAREHOUSE IDENTIFICATION:');
            console.log('  Warehouse locations (have both pickups & deliveries):', 
                warehouseLocations.map(([loc, data]) => {
                    const pickupSCU = data.pickups.reduce((s, p) => s + p.scu, 0);
                    const deliverySCU = data.deliveries.reduce((s, d) => s + d.scu, 0);
                    const destinations = new Set(data.pickups.map(p => p.destination)).size;
                    return `${loc} (${pickupSCU} SCU pickup to ${destinations} destinations, ${deliverySCU} SCU delivery)`;
                }));
            console.log(`  Primary warehouse: ${primaryWarehouse}`);
            console.log('');
            
            // Keep visiting locations until everything is delivered
            let iteration = 0;
            while (allDeliveryIds.size > 0 || allPickupIds.size > 0) {
                iteration++;
                console.log(`\nâ”â”â” ITERATION ${iteration} â”â”â”`);
                console.log(`Cargo on board: ${currentCargo} SCU`);
                console.log(`Pickups remaining: ${allPickupIds.size}`);
                console.log(`Deliveries remaining: ${allDeliveryIds.size}`);
                console.log(`Stops so far: ${stops.map(s => s.location).join(' â†’ ')}`);
                console.log('');
                let bestLocation = null;
                let bestScore = -1;
                
                // Force first stop to be the primary warehouse (if it has pickups)
                if (primaryWarehouse && 
                    stops.length === 0 && 
                    locationMap[primaryWarehouse].pickups.some(p => allPickupIds.has(p.id))) {
                    bestLocation = primaryWarehouse;
                    console.log('âœ… Forcing first stop to primary warehouse:', primaryWarehouse);
                } else {
                    // Find the best next location to visit
                    console.log('ðŸ” EVALUATING LOCATIONS:');
                    for (const location of Object.keys(locationMap)) {
                        const hasUnpickedCargo = locationMap[location].pickups.some(p => allPickupIds.has(p.id));
                        const hasReadyDeliveries = locationMap[location].deliveries.some(d => cargoOnBoard.has(d.id));
                        
                        console.log(`  ${location}:`);
                        console.log(`    - Has unpicked cargo: ${hasUnpickedCargo}`);
                        console.log(`    - Has ready deliveries: ${hasReadyDeliveries}`);
                        
                        if (!hasUnpickedCargo && !hasReadyDeliveries) {
                            console.log(`    â­ï¸  SKIP: Nothing to do here`);
                            continue;
                        }
                        
                        // FIX: Block return-to-warehouse until all other stops are complete
                        const isWarehouse = location === primaryWarehouse;
                        const hasDeliveriesHere = locationMap[location].deliveries.some(d => cargoOnBoard.has(d.id));
                        
                        console.log(`    - Is primary warehouse: ${isWarehouse}`);
                        
                        // Block warehouse return if ANY non-warehouse location has pending deliveries
                        if (isWarehouse && hasDeliveriesHere) {
                            console.log(`    ðŸ”’ WAREHOUSE RETURN CHECK:`);
                            
                            // Check if any non-warehouse location has pending deliveries (on board or not)
                            const otherLocationsPending = [];
                            for (const [loc, data] of Object.entries(locationMap)) {
                                if (loc !== primaryWarehouse) {
                                    const pendingHere = data.deliveries.filter(d => allDeliveryIds.has(d.id)).length;
                                    if (pendingHere > 0) {
                                        otherLocationsPending.push(`${loc} (${pendingHere} pending)`);
                                    }
                                }
                            }
                            
                            if (otherLocationsPending.length > 0) {
                                console.log(`    ðŸš« BLOCKED: ${otherLocationsPending.join(', ')}`);
                                continue; // Skip warehouse - deliver to other locations first
                            } else {
                                console.log(`    âœ… ALLOWED: All non-warehouse deliveries complete`);
                            }
                        }
                        
                        // Score by actual SCU delivered/picked up (not just item count)
                        const deliverySCU = locationMap[location].deliveries
                            .filter(d => cargoOnBoard.has(d.id))
                            .reduce((s, d) => s + d.scu, 0);
                        
                        const pickupSCU = locationMap[location].pickups
                            .filter(p => allPickupIds.has(p.id))
                            .reduce((s, p) => s + p.scu, 0);
                        
                        let score = 0;
                        const deliveryScore = deliverySCU * 3;
                        const pickupScore = pickupSCU * 2;
                        const comboBonus = (deliverySCU > 0 && pickupSCU > 0) ? 200 : 0;
                        
                        score = deliveryScore + pickupScore + comboBonus;
                        
                        console.log(`    ðŸ“Š SCORING:`);
                        console.log(`       - Delivery: ${deliverySCU} SCU Ã— 3 = ${deliveryScore}`);
                        console.log(`       - Pickup: ${pickupSCU} SCU Ã— 2 = ${pickupScore}`);
                        console.log(`       - Combo bonus: ${comboBonus}`);
                        console.log(`       - TOTAL SCORE: ${score}`);
                        
                        if (score > bestScore) {
                            console.log(`    â­ NEW BEST LOCATION!`);
                            bestScore = score;
                            bestLocation = location;
                        }
                    }
                }
                
                if (!bestLocation) {
                    console.error('âŒ Route planner: No valid next location found');
                    console.log('   Final state:');
                    console.log(`   - Pickups remaining: ${allPickupIds.size}`);
                    console.log(`   - Deliveries remaining: ${allDeliveryIds.size}`);
                    console.log(`   - Cargo on board IDs:`, Array.from(cargoOnBoard));
                    break; // Safety check
                }
                
                console.log(`\nâœ… SELECTED: ${bestLocation} (score: ${bestScore})`);
                
                // Visit this location and do ALL possible actions in ONE stop
                const loc = locationMap[bestLocation];
                const pickupsHere = loc.pickups.filter(p => allPickupIds.has(p.id));
                const deliveriesHere = loc.deliveries.filter(d => cargoOnBoard.has(d.id));
                
                if (pickupsHere.length === 0 && deliveriesHere.length === 0) {
                    console.error('âŒ Route planner: Selected location has no valid actions');
                    break;
                }
                
                const deliverySCU = deliveriesHere.reduce((sum, d) => sum + d.scu, 0);
                const pickupSCU = pickupsHere.reduce((sum, p) => sum + p.scu, 0);
                
                console.log(`ðŸ“ STOP ${stops.length + 1}: ${bestLocation}`);
                if (deliveriesHere.length > 0) {
                    console.log(`   ðŸ“­ Delivering ${deliverySCU} SCU:`);
                    deliveriesHere.forEach(d => {
                        console.log(`      - Mission ${d.missionNum}: ${d.commodity} ${d.scu} SCU`);
                    });
                }
                if (pickupsHere.length > 0) {
                    console.log(`   ðŸ“¦ Picking up ${pickupSCU} SCU:`);
                    pickupsHere.forEach(p => {
                        console.log(`      - Mission ${p.missionNum}: ${p.commodity} ${p.scu} SCU â†’ ${p.destination}`);
                    });
                }
                console.log(`   Cargo: ${currentCargo} â†’ ${currentCargo - deliverySCU + pickupSCU} SCU`);
                
                // Record this stop (with both pickups AND deliveries)
                stops.push({
                    location: bestLocation,
                    pickups: pickupsHere,
                    deliveries: deliveriesHere,
                    cargoBeforeStop: currentCargo,
                    cargoAfterStop: currentCargo - deliverySCU + pickupSCU
                });
                
                // Update cargo state - deliveries first (free space), then pickups
                deliveriesHere.forEach(d => {
                    cargoOnBoard.delete(d.id);
                    allDeliveryIds.delete(d.id);
                });
                
                pickupsHere.forEach(p => {
                    cargoOnBoard.add(p.id);
                    allPickupIds.delete(p.id);
                });
                
                currentCargo = currentCargo - deliverySCU + pickupSCU;
            }
            
            console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('âœ… ROUTE GENERATION COMPLETE');
            console.log(`Total stops: ${stops.length}`);
            console.log(`Route: ${stops.map(s => s.location).join(' â†’ ')}`);
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
            
            // Store stops and render
            routeStops = stops;
            renderRoutePlan(stops);
        }
        
        // Render route plan (separated so we can re-render after drag)
        function renderRoutePlan(stops) {
            const container = document.getElementById('routePlanner');
            const shipCapacity = selectedShip ? selectedShip.capacity : 999999;
            
            // Recalculate cargo levels based on current order
            let currentCargo = 0;
            stops.forEach(stop => {
                stop.cargoBeforeStop = currentCargo;
                const pickupSCU = stop.pickups.reduce((sum, p) => sum + p.scu, 0);
                const deliverySCU = stop.deliveries.reduce((sum, d) => sum + d.scu, 0);
                currentCargo = currentCargo - deliverySCU + pickupSCU;
                stop.cargoAfterStop = currentCargo;
            });
            
            // Determine which stops to show based on view mode
            let stopsToShow = stops;
            const currentIndex = getCurrentStepIndex(stops.length);
            
            if (routeViewMode === 'current') {
                stopsToShow = [stops[currentIndex]];
            } else if (routeViewMode === 'current-next') {
                if (currentIndex < stops.length - 1) {
                    stopsToShow = [stops[currentIndex], stops[currentIndex + 1]];
                } else {
                    stopsToShow = [stops[currentIndex]];
                }
            }
            
            container.innerHTML = `
                <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 20px; text-transform: uppercase; letter-spacing: 1px;">
                    Optimized Route - ${stops.length} Stops
                </div>
                ${stopsToShow.map((stop) => {
                    // Find the actual index in the full stops array
                    const actualIndex = stops.indexOf(stop);
                    const hasDeliveries = stop.deliveries && stop.deliveries.length > 0;
                    const hasPickups = stop.pickups && stop.pickups.length > 0;
                    const isCompleted = routeStepCompletion[actualIndex];
                    const isCurrent = actualIndex === currentIndex;
                    
                    // Compact view for completed stops
                    if (isCompleted) {
                        return `
                            <div class="route-stop route-stop-completed" data-stop-index="${actualIndex}">
                                <div style="display: flex; align-items: center; gap: 12px;">
                                    <input type="checkbox" 
                                           checked 
                                           onchange="toggleRouteStepCompletion(${actualIndex})"
                                           style="width: 20px; height: 20px; cursor: pointer; accent-color: var(--color-success);">
                                    <div style="flex: 1;">
                                        <span style="font-weight: 600;">Stop ${actualIndex + 1}: ${stop.location}</span>
                                        <span style="margin-left: 12px; color: var(--color-success);">âœ“ Completed</span>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                    
                    // Full view for non-completed stops
                    return `
                        <div class="route-stop ${isCurrent ? 'route-stop-current' : ''}" data-stop-index="${actualIndex}" draggable="true">
                            <div class="route-stop-header">
                                <div style="display: flex; align-items: center; gap: 12px; flex: 1;">
                                    <input type="checkbox" 
                                           ${isCompleted ? 'checked' : ''} 
                                           onchange="toggleRouteStepCompletion(${actualIndex})"
                                           style="width: 20px; height: 20px; cursor: pointer; accent-color: var(--color-success);">
                                    <div class="route-stop-title">Stop ${actualIndex + 1}: ${stop.location}</div>
                                </div>
                                <div class="route-cargo-status">Cargo: ${stop.cargoAfterStop}/${selectedShip ? shipCapacity : '--'} SCU</div>
                            </div>
                            
                            ${hasDeliveries ? `
                                <div class="route-action-section">
                                    <div class="route-action-header" style="color: var(--color-success);">
                                        <span style="font-size: 16px; margin-right: 8px;">â–¼</span> DELIVERY
                                    </div>
                                    ${stop.deliveries.map(item => {
                                        const group = cargoGroups[stop.location];
                                        return `
                                            <div class="route-mission-item" style="border-left: 3px solid ${group?.color || '#888'}; padding-left: 12px; margin-left: 20px;">
                                                <span class="mission-number">Mission ${item.missionNum}:</span>
                                                <span class="commodity">${item.commodity}</span>
                                                <span>(${item.scu} SCU)</span>
                                                <span style="color: ${group?.color || '#888'}; font-weight: 600; margin-left: 8px;">Group ${group?.label || '?'}</span>
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            ` : ''}
                            
                            ${hasPickups ? `
                                <div class="route-action-section">
                                    <div class="route-action-header" style="color: var(--color-warning);">
                                        <span style="font-size: 16px; margin-right: 8px;">â–²</span> PICKUP
                                    </div>
                                    ${stop.pickups.map(item => {
                                        const group = cargoGroups[item.destination];
                                        return `
                                            <div class="route-mission-item" style="border-left: 3px solid ${group?.color || '#888'}; padding-left: 12px; margin-left: 20px;">
                                                <span class="mission-number">Mission ${item.missionNum}:</span>
                                                <span class="commodity">${item.commodity}</span>
                                                <span>(${item.scu} SCU)</span>
                                                <span style="color: ${group?.color || '#888'}; font-weight: 600; margin-left: 8px;">â†’ Group ${group?.label || '?'}</span>
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            ` : ''}
                        </div>
                    `;
                }).join('')}
            `;
        }





        // Group deliveries by commodity

        // Update stats
        function updateStats() {
            // Calculate total payout
            let totalPayout = 0;
            missions.forEach(mission => {
                if (mission.payout) {
                    // Handle both string ("40k") and number (40000) formats
                    if (typeof mission.payout === 'string') {
                        totalPayout += parseFloat(mission.payout.replace('k', '')) * 1000;
                    } else if (typeof mission.payout === 'number') {
                        totalPayout += mission.payout;
                    }
                }
            });
            
            // Format with commas
            const payoutFormatted = totalPayout.toLocaleString('en-US');
            document.getElementById('totalPayout').textContent = payoutFormatted;
            
            // Calculate total SCU
            let totalSCU = 0;
            missions.forEach(mission => {
                mission.commodities.forEach(commodity => {
                    if (commodity.quantity) {
                        totalSCU += parseInt(commodity.quantity) || 0;
                    }
                });
            });
            
            document.getElementById('scuTotal').textContent = totalSCU;
            
            // Update capacity meter
            if (selectedShip) {
                const percentage = Math.min((totalSCU / selectedShip.capacity) * 100, 100);
                const fill = document.getElementById('capacityFill');
                fill.style.width = percentage + '%';
                
                if (totalSCU > selectedShip.capacity) {
                    fill.classList.add('over-capacity');
                } else {
                    fill.classList.remove('over-capacity');
                }
                
                document.getElementById('capacityText').textContent = 
                    `${totalSCU} / ${selectedShip.capacity} SCU`;
            } else {
                document.getElementById('capacityText').textContent = '0 / 0 SCU';
                document.getElementById('capacityFill').style.width = '0%';
            }
        }

        // Color picker functions
        function openColorPicker(location) {
            currentColorTarget = location;
            const modal = document.getElementById('colorPickerModal');
            modal.classList.add('active');
            
            const currentColor = locationColors[location].color;
            document.getElementById('customColorInput').value = currentColor;
        }

        function closeColorPicker() {
            document.getElementById('colorPickerModal').classList.remove('active');
            currentColorTarget = null;
        }

        function selectPresetColor(color) {
            document.getElementById('customColorInput').value = color;
        }



        function updateMarkerLabel(location, label) {
            locationColors[location].label = label;
            saveSession();
        }

        // Session management
        function saveSession() {
            if (isLoadingSession) {
                console.log('â¸ï¸ Skipping save - currently loading session');
                return;
            }
            
            console.log('ðŸ’¾ saveSession() called! Current state:', {
                ship: selectedShip?.id,
                system: selectedSystem,
                category: selectedCategory,
                missionsCount: missions.length
            });
            const session = {
                ship: selectedShip?.id,
                system: selectedSystem,
                category: selectedCategory,
                missions: missions,
                locationColors: locationColors,
                cargoGroups: cargoGroups,
                routeStepCompletion: routeStepCompletion,
                timestamp: new Date().toISOString()
            };
            localStorage.setItem('haulerHelperSession', JSON.stringify(session));
        }

        function loadSession() {
            console.log('ðŸ”µ loadSession() called!');
            const saved = localStorage.getItem('haulerHelperSession');
            console.log('ðŸ”µ Saved data:', saved);
            if (!saved) return;

            isLoadingSession = true; // ðŸ”’ Block saves during load
            
            try {
                const session = JSON.parse(saved);
                
                // Restore selections
                if (session.ship) {
                    selectedShip = ships.find(s => s.id === session.ship);
                    if (selectedShip) {
                        document.getElementById('shipSelect').value = selectedShip.name;
                    }
                }
                if (session.system) {
                    document.getElementById('systemSelect').value = session.system;
                    selectedSystem = session.system;
                }
                if (session.category) {
                    document.getElementById('categorySelect').value = session.category;
                    selectedCategory = session.category;
                }
                
                // Restore missions
                if (session.missions) {
                    missions = session.missions;
                    missionCounter = missions.length;
                    
                    const container = document.getElementById('missionsContainer');
                    container.innerHTML = '';
                    
                    missions.forEach((mission, index) => {
                        const panel = createMissionPanel(mission.id, index + 1);
                        container.appendChild(panel);
                        
                        // Set payout
                        const payoutSelect = panel.querySelector('select');
                        if (payoutSelect && mission.payout) {
                            payoutSelect.value = mission.payout;
                        }
                        
                        // Restore commodities
                        const commoditiesContainer = document.getElementById(`${mission.id}_commodities`);
                        mission.commodities.forEach((commodity, cIndex) => {
                            const row = createCommodityRow(mission.id, commodity.id, cIndex > 0);
                            commoditiesContainer.appendChild(row);
                            
                            // Set values
                            const selects = row.querySelectorAll('select');
                            const input = row.querySelector('input');
                            if (selects[0]) selects[0].value = commodity.pickup || '';
                            if (selects[1]) selects[1].value = commodity.commodity || '';
                            if (input) input.value = commodity.quantity || '';
                            if (selects[2]) selects[2].value = commodity.maxBoxSize || '4';
                            if (selects[3]) selects[3].value = commodity.destination || '';
                        });
                    });
                }
                
                                
                // Restore route completion state
                if (session.routeStepCompletion) {
                    routeStepCompletion = session.routeStepCompletion;
                }
                
// Restore location colors
                if (session.locationColors) {
                    locationColors = session.locationColors;
                }
                
                // Restore cargo groups
                if (session.cargoGroups) {
                    cargoGroups = session.cargoGroups;
                }
                
                // Generate route plan and cargo grid
                generateRoutePlan();
                generateCargoGrid();
                updateStats();
            } catch (e) {
                console.error('âŒ Error loading session:', e);
                console.error('âŒ Error stack:', e.stack);
            } finally {
        isLoadingSession = false; // ðŸ”“ Allow saves again
    }
}

        // =============================================================================
        // MISSION DATA EXPORT FUNCTIONS
        // =============================================================================
        
        /**
         * Export current session data to JSON file for analysis
         * Captures all mission details for pattern identification
         */
        function exportSessionData() {
            if (missions.length === 0) {
                alert('No missions to export. Add some missions first!');
                return;
            }
            
            // Build export data structure
            const exportData = {
                metadata: {
                    exportDate: new Date().toISOString(),
                    version: '3.3.6',
                    system: selectedSystem,
                    category: selectedCategory,
                    ship: selectedShip ? {
                        id: selectedShip.id,
                        name: selectedShip.name,
                        capacity: selectedShip.capacity
                    } : null
                },
                missions: missions.map(mission => ({
                    payout: mission.payout,
                    commodities: mission.commodities.map(commodity => ({
                        pickup: commodity.pickup,
                        commodity: commodity.commodity,
                        quantity: parseInt(commodity.quantity) || 0,
                        maxBoxSize: parseInt(commodity.maxBoxSize) || 4,
                        destination: commodity.destination
                    })).filter(c => c.commodity) // Only include commodities with a name
                })).filter(m => m.commodities.length > 0), // Only include missions with commodities
                statistics: {
                    totalMissions: missions.length,
                    totalPayout: missions.reduce((sum, m) => {
                        if (!m.payout) return sum;
                        // Handle both string ("40k") and number formats
                        if (typeof m.payout === 'string') {
                            return sum + (parseInt(m.payout.replace('k', '')) * 1000);
                        } else if (typeof m.payout === 'number') {
                            return sum + m.payout;
                        }
                        return sum;
                    }, 0),
                    totalSCU: missions.reduce((sum, m) => {
                        return sum + m.commodities.reduce((cSum, c) => {
                            return cSum + (parseInt(c.quantity) || 0);
                        }, 0);
                    }, 0)
                }
            };
            
            // Create filename with timestamp
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const filename = `HaulerHelper_${selectedSystem || 'unknown'}_${selectedCategory || 'unknown'}_${timestamp}.json`;
            
            // Download JSON file
            downloadJSON(exportData, filename);
            
            console.log('âœ… Session data exported:', filename);
            console.log('ðŸ“Š Statistics:', exportData.statistics);
        }
        
        /**
         * Export current session data to CSV for Excel analysis
         * One row per commodity delivery
         */
        function exportSessionCSV() {
            if (missions.length === 0) {
                alert('No missions to export. Add some missions first!');
                return;
            }
            
            // Build CSV data
            const rows = [];
            
            // Header row
            rows.push([
                'Export Date',
                'System',
                'Category',
                'Ship',
                'Ship Capacity',
                'Mission Number',
                'Payout',
                'Commodity Number',
                'Pickup Location',
                'Commodity',
                'Quantity (SCU)',
                'Max Box Size',
                'Destination Location'
            ]);
            
            // Data rows
            const exportDate = new Date().toISOString().split('T')[0];
            missions.forEach((mission, missionIndex) => {
                mission.commodities.forEach((commodity, commodityIndex) => {
                    if (!commodity.commodity) return; // Skip empty commodities
                    
                    rows.push([
                        exportDate,
                        selectedSystem || '',
                        selectedCategory || '',
                        selectedShip ? selectedShip.name : '',
                        selectedShip ? selectedShip.capacity : '',
                        missionIndex + 1,
                        mission.payout || '',
                        commodityIndex + 1,
                        commodity.pickup || '',
                        commodity.commodity || '',
                        commodity.quantity || '',
                        commodity.maxBoxSize || '4',
                        commodity.destination || ''
                    ]);
                });
            });
            
            // Convert to CSV string
            const csvContent = rows.map(row => 
                row.map(cell => {
                    // Escape quotes and wrap in quotes if contains comma
                    const cellStr = String(cell);
                    if (cellStr.includes(',') || cellStr.includes('"')) {
                        return '"' + cellStr.replace(/"/g, '""') + '"';
                    }
                    return cellStr;
                }).join(',')
            ).join('\n');
            
            // Create filename with timestamp
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const filename = `HaulerHelper_${selectedSystem || 'unknown'}_${selectedCategory || 'unknown'}_${timestamp}.csv`;
            
            // Download CSV file
            downloadCSV(csvContent, filename);
            
            console.log('âœ… Session data exported to CSV:', filename);
        }
        
        /**
         * Download JSON data as a file
         */
        function downloadJSON(data, filename) {
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        /**
         * Download CSV data as a file
         */
        function downloadCSV(csvContent, filename) {
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

                // Initialize on load
        window.onload = init;

        // Reset missions only (keep ship, system, category, theme)
        function resetMissions() {
            if (confirm('Clear all missions? This will remove all mission data but keep your ship, system, category, and theme settings.')) {
                // Clear missions
                missions = [];
                missionCounter = 0;
                locationColors = {};
                deliveryOrder = [];
                commodityOrder = [];
                cargoGridOrder = [];
                cargoGroups = {};
                
                // Clear mission panels
                document.getElementById('missionsContainer').innerHTML = '';
                
                // Update displays
                // updateDeliverySummary removed
                updateStats();
                saveSession();
            }
        }

        // Reset function
        function resetAll() {
            if (confirm('Reset everything? This will clear all missions, selections, colors, and preferences. This cannot be undone.')) {
                // Clear all localStorage
                localStorage.removeItem('haulerHelperSession');
                localStorage.removeItem('haulerHelperTheme');
                localStorage.removeItem('haulerHelperDeliveryLayout');
                localStorage.removeItem('haulerHelperDeliveryOrder');
                localStorage.removeItem('haulerHelperCommodityOrder');
                localStorage.removeItem('haulerHelperOrganizerGroupBy');
                
                // Reload the page to reset everything
                location.reload();
            }
        }
    </script>

    <button class="btn-reset" onclick="resetMissions()" title="Clear missions only" style="bottom: 80px;">Reset Missions</button>
        <!-- Export Buttons -->
    <div class="export-buttons-bottom">
        <button class="btn-export-bottom" onclick="exportSessionData()" title="Export as JSON for analysis">
            ðŸ“Š Export JSON
        </button>
        <button class="btn-export-bottom" onclick="exportSessionCSV()" title="Export as CSV for Excel">
            ðŸ“ˆ Export CSV
        </button>
    </div>

    <button class="btn-reset" onclick="resetAll()" title="Reset all data and preferences">Reset All</button>

    <footer class="footer">
        This is an unofficial Star Citizen fansite, not affiliated with the Cloud Imperium group of companies.<br>
        2025 Wednesdaywoe<br>
        <a href="https://www.youtube.com/@wednesdaywoeplays" target="_blank">youtube.com/@wednesdaywoeplays</a>
    </footer>
</body>
</html>
