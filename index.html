<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hauler Helper - Star Citizen</title>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <link rel="stylesheet" href="css/themes.css">
    <link rel="stylesheet" href="css/main.css">
</head>
<body data-theme="stardust">
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>HAULER HELPER</h1>
            <div class="subtitle">Your Ship Manifest for Star Citizen</div>
            <div style="font-weight: bold; color: var(--color-warning); font-size: 11px; margin-top: 10px; letter-spacing: 1px;">
                THIS IS A WORK IN PROGRESS, EXPECT BUGS AND MISSING/INCORRECT INFORMATION
            </div>
        </div>
        
        <!-- Decorative gradient line -->
        <div style="width: 100%; height: 2px; margin: 25px 0 30px 0; background: linear-gradient(90deg, transparent 0%, var(--color-primary) 50%, transparent 100%);"></div>

        <!-- Controls -->
        <div class="controls">
            <div class="control-group">
                <label>Ship</label>
                <input type="text" id="shipSelect" list="shipList" placeholder="Search or select ship..." onchange="updateShip()" autocomplete="off">
                <datalist id="shipList">
                </datalist>
            </div>
            <div class="control-group">
                <label>System</label>
                <select id="systemSelect" onchange="updateSystem()">
                    <option value="">Select System</option>
                    <option value="microtech">microTech</option>
                    <option value="hurston" disabled>Hurston (Coming Soon)</option>
                    <option value="arccorp" disabled>ArcCorp (Coming Soon)</option>
                    <option value="crusader" disabled>Crusader (Coming Soon)</option>
                    <option value="nyx" disabled>Nyx (Coming Soon)</option>
                    <option value="pyro" disabled>Pyro (Coming Soon)</option>
                </select>
            </div>
            <div class="control-group">
                <label>Mission Category</label>
                <select id="categorySelect" onchange="updateCategory()">
                    <option value="">Select Category</option>
                    <option value="planetary">Planetary</option>
                    <option value="local">Local</option>
                    <option value="stellar">Stellar</option>
                    <option value="interstellar">Interstellar</option>
                </select>
            </div>
            <div class="control-group">
                <label>Theme</label>
                <select id="themeSelect" onchange="changeTheme()">
                    <option value="stardust">Stardust</option>
                    <option value="lux">Lux</option>
                    <option value="pulse">Pulse</option>
                    <option value="flow">Flow</option>
                    <option value="dark">Dark</option>
                    <option value="starkitten">Starkitten</option>
                    <option value="wednesday">Wednesday</option>
                    <option value="moonshine">Moonshine</option>
                    <option value="argo">ARGO</option>
                    <option value="cassette">Cassette</option>
                    <option value="cargo-explorer">Cargo Explorer</option>
                </select>
            </div>
        </div>

        <!-- Main Layout -->
        <div class="main-layout">
            <!-- Column 1: Mission Panels -->
            <div class="missions-column">
                <!-- Screenshot OCR Section -->
                <div class="ocr-section">
                    <div class="ocr-header">
                        <div class="ocr-title">ðŸ“¸ Screenshot Scanner (Experimental)</div>
                        <button class="ocr-toggle" onclick="toggleOCRSection()">Show</button>
                    </div>
                    <div class="ocr-content" id="ocrContent">
                        <input type="file" id="ocrFileInput" class="ocr-file-input" accept="image/*" onchange="processScreenshot(event)">
                        <div class="ocr-upload-area" id="ocrUploadArea" onclick="document.getElementById('ocrFileInput').click()">
                            <div class="ocr-upload-icon">ðŸ“·</div>
                            <div class="ocr-upload-text">Click to upload mission screenshot</div>
                            <div class="ocr-upload-hint">Supports PNG, JPG, or any image format</div>
                        </div>
                        <div class="ocr-status" id="ocrStatus" style="display: none;"></div>
                    </div>
                </div>

                <div class="missions-scroll" id="missionsContainer">
                    <!-- Mission panels will be added here -->
                </div>
                <button class="btn-add-mission" onclick="addMissionPanel()">+ Add Mission</button>
            </div>

            <!-- Column 2: Delivery Manager -->
            <div class="delivery-summary">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2>Delivery Manager</h2>
                </div>
                
                <!-- Tab Navigation -->
                <div class="delivery-tabs">
                    <button class="tab-button active" onclick="switchDeliveryTab('route')">Route Planner</button>
                    <button class="tab-button" onclick="switchDeliveryTab('grid')">Visualizer</button>
                </div>
                

                <!-- Cargo Grid Tab -->
                <div id="gridTab" class="tab-content" style="display: none;">
                    <div class="grid-layout-selector">
                        <span style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 1px;">Columns:</span>
                        <select id="gridColumns" onchange="updateGridLayout()" style="background-color: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); padding: 6px 10px; border-radius: 4px; font-size: 12px;">
                            <option value="1">1</option>
                            <option value="2">2</option>
                            <option value="3" selected>3</option>
                            <option value="4">4</option>
                        </select>
                        <span style="font-size: 11px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 1px; margin-left: 15px;">Rows:</span>
                        <select id="gridRows" onchange="updateGridLayout()" style="background-color: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); padding: 6px 10px; border-radius: 4px; font-size: 12px;">
                            <option value="1">1</option>
                            <option value="2">2</option>
                            <option value="3" selected>3</option>
                            <option value="4">4</option>
                            <option value="5">5</option>
                            <option value="6">6</option>
                            <option value="7">7</option>
                            <option value="8">8</option>
                            <option value="9">9</option>
                            <option value="10">10</option>
                        </select>
                    </div>
                    <div id="cargoGrid" class="cargo-grid-container layout-2x1">
                        <div class="empty-state">No cargo groups to display</div>
                    </div>
                </div>
                
                <!-- Route Planner Tab -->
                <div id="routeTab" class="tab-content" style="display: block;">
                    <div id="routePlanner">
                        <div class="empty-state">No route planned</div>
                    </div>
                </div>
            </div>

            <!-- Column 3: Stats -->
            <div class="stats-column">
                <div class="stat-panel">
                    <div class="stat-label">Total Payout</div>
                    <div class="stat-value" id="totalPayout">0K</div>
                </div>
                <div class="stat-panel">
                    <div class="stat-label">SCU Total</div>
                    <div class="stat-value" id="scuTotal">0</div>
                    <div class="capacity-meter">
                        <div class="capacity-bar">
                            <div class="capacity-fill" id="capacityFill" style="width: 0%"></div>
                        </div>
                        <div class="capacity-text" id="capacityText">0 / 0 SCU</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Color Picker Modal -->
    <div class="color-picker-modal" id="colorPickerModal">
        <div class="color-picker-content">
            <div class="color-picker-title">Choose Marker Color</div>
            <div class="color-palette theme-colors" id="colorPalette">
                <!-- Colors will be populated dynamically -->
            </div>
            <input type="color" class="custom-color-input" id="customColorInput">
            <div class="color-picker-buttons">
                <button class="btn-color-picker btn-cancel" onclick="closeColorPicker()">Cancel</button>
                <button class="btn-color-picker btn-confirm" onclick="confirmColor()">Confirm</button>
            </div>
        </div>
    </div>

    <script src="js/data/theme-colors.js?v=2"></script>
    <script src="js/data/ships.js?v=2"></script>
    <script src="js/data/locations.js?v=2"></script>
    <script src="js/data/commodities.js?v=3"></script>
    <script src="js/data/payouts.js?v=2"></script>
    
    <script>
        // Data
        let missionCounter = 0;
        let selectedShip = null;
        let selectedSystem = null;
        let selectedCategory = null;
        let missions = [];
        let locationColors = {};
        let deliveryOrder = []; // Track custom order of delivery locations
        let commodityOrder = []; // Track custom order of commodities
        let cargoGridLayout = '2x1'; // Track cargo grid layout
        let cargoGridOrder = []; // Track custom order of groups in cargo grid
        let cargoGroups = {}; // Store cargo groups for persistent colors/labels
        let currentColorTarget = null;
        let isLoadingSession = false;  // â† ADD THIS LINE

        // Theme color palettes
        const themeColorPalettes = THEME_COLOR_PALETTES;

        // Ships database (sorted alphabetically by name)
        const ships = SHIPS_DATABASE;

        // Locations database (sorted alphabetically)
        const locations = LOCATIONS_DATABASE;

        // Commodities database (sorted alphabetically)
        const commodities = COMMODITIES_DATABASE;

        // Payouts database (sorted numerically low to high)
        const payouts = PAYOUTS_DATABASE;


        // Load cargo grid expanded state
        function loadCargoGridExpandedState() {
            const saved = localStorage.getItem('haulerHelperCargoGridExpanded');
            if (saved === 'true') {
                cargoGridExpanded = true;
            }
        }

        // Initialize
        function init() {
            console.log('%cðŸŽ¯ HAULER HELPER v3.3.0 - ROUTE SOLVER FIXES', 'background: #4dd4ac; color: #000; font-size: 16px; padding: 8px;');

            // HANDLE dragstart at document level (since addEventListener on cards doesn't work)
            document.addEventListener('dragstart', function(e) {
                // Check if it's a cargo card
                if (e.target.classList && e.target.classList.contains('cargo-group-card')) {
                    handleCargoGridDragStart(e);
                }
            }, true); // Use capture phase
            
            document.addEventListener('dragend', function(e) {
                if (e.target.classList && e.target.classList.contains('cargo-group-card')) {
                    handleCargoGridDragEnd(e);
                }
            }, true);
            
            document.addEventListener('dragover', function(e) {
                if ((e.target.classList && e.target.classList.contains('cargo-group-card')) ||
                    (e.target.classList && e.target.classList.contains('empty-cell'))) {
                    handleCargoGridDragOver(e);
                }
            }, true);
            
            document.addEventListener('drop', function(e) {
                if ((e.target.classList && e.target.classList.contains('cargo-group-card')) ||
                    (e.target.classList && e.target.classList.contains('empty-cell'))) {
                    handleCargoGridDrop(e);
                }
            }, true);
            
            // Route stop drag handlers
            document.addEventListener('dragstart', function(e) {
                if (e.target.classList && e.target.classList.contains('route-stop')) {
                    handleRouteStopDragStart(e);
                }
            }, true);
            
            document.addEventListener('dragend', function(e) {
                if (e.target.classList && e.target.classList.contains('route-stop')) {
                    handleRouteStopDragEnd(e);
                }
            }, true);
            
            document.addEventListener('dragover', function(e) {
                if (e.target.closest && e.target.closest('.route-stop')) {
                    handleRouteStopDragOver(e);
                }
            }, true);
            
            document.addEventListener('drop', function(e) {
                if (e.target.closest && e.target.closest('.route-stop')) {
                    handleRouteStopDrop(e);
                }
            }, true);
            


            populateShipSelect();
            loadSession();
            loadTheme();
            loadDeliveryLayout();
            loadDeliveryOrder();
            loadCommodityOrder();
            loadCargoGridLayout();
            updateColorPalette();
        }

        // Load delivery layout preference (removed - tabs removed)
        function loadDeliveryLayout() {
            // Function removed - By Location and By Commodity tabs removed
        }

        // Populate ship select
        function populateShipSelect() {
            const datalist = document.getElementById('shipList');
            datalist.innerHTML = '';
            ships.forEach(ship => {
                const option = document.createElement('option');
                option.value = ship.name;
                option.setAttribute('data-id', ship.id);
                datalist.appendChild(option);
            });
        }

        // Update ship
        function updateShip() {
            const input = document.getElementById('shipSelect');
            const selectedName = input.value;
            
            // Find ship by name
            const ship = ships.find(s => s.name === selectedName);
            
            if (ship) {
                selectedShip = ship;
                input.value = ship.name; // Set to full name
            } else {
                selectedShip = null;
                input.value = ''; // Clear invalid input
            }
            
            updateStats();
            saveSession();
        }

        // Update system
        function updateSystem() {
            selectedSystem = document.getElementById('systemSelect').value;
            saveSession();
        }

        // Update category
        function updateCategory() {
            selectedCategory = document.getElementById('categorySelect').value;
            saveSession();
        }

        // Change theme
        function changeTheme() {
            const theme = document.getElementById('themeSelect').value;
            document.body.setAttribute('data-theme', theme);
            localStorage.setItem('haulerHelperTheme', theme);
            updateColorPalette();
        }

        // Toggle delivery organizer layout
        function toggleDeliveryLayout() {
            // const container = document.getElementById('deliverySummary'); // Removed - By Location tab removed
            // const containerCommodity = document.getElementById('deliverySummaryCommodity'); // Removed - By Commodity tab removed
            const icon = document.getElementById('layoutIcon');
            const iconCommodity = document.getElementById('layoutIconCommodity');
            
            if (container.classList.contains('two-column')) {
                container.classList.remove('two-column');
                containerCommodity.classList.remove('two-column');
                icon.textContent = 'âš'; // Single column icon
                iconCommodity.textContent = 'âš';
                localStorage.setItem('haulerHelperDeliveryLayout', 'single');
            } else {
                container.classList.add('two-column');
                containerCommodity.classList.add('two-column');
                icon.textContent = 'â˜°'; // Two column icon
                iconCommodity.textContent = 'â˜°';
                localStorage.setItem('haulerHelperDeliveryLayout', 'two-column');
            }
        }

        // Drag and drop handlers for delivery organizer
        let draggedElement = null;

        function handleDragStart(e) {
            draggedElement = e.target;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.innerHTML);
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            
            // Remove drag-over class from all elements
            document.querySelectorAll('.delivery-location').forEach(el => {
                el.classList.remove('drag-over');
            });
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        // OCR Screenshot Processing
        function toggleOCRSection() {
            const content = document.getElementById('ocrContent');
            const button = event.target;
            
            if (content.classList.contains('active')) {
                content.classList.remove('active');
                button.textContent = 'Show';
            } else {
                content.classList.add('active');
                button.textContent = 'Hide';
            }
        }

        function processScreenshot(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const uploadArea = document.getElementById('ocrUploadArea');
            const status = document.getElementById('ocrStatus');
            
            // Show processing state
            uploadArea.classList.add('processing');
            status.style.display = 'block';
            status.className = 'ocr-status processing';
            status.textContent = 'Processing screenshot... This may take 10-30 seconds.';
            
            // Create image element
            const reader = new FileReader();
            reader.onload = function(e) {
                const imageData = e.target.result;
                
                // Run Tesseract OCR
                Tesseract.recognize(
                    imageData,
                    'eng',
                    {
                        logger: m => {
                            if (m.status === 'recognizing text') {
                                const percent = Math.round(m.progress * 100);
                                status.textContent = `Processing: ${percent}%`;
                            }
                        }
                    }
                ).then(({ data: { text } }) => {
                    console.log('OCR Text:', text);
                    
                    // Parse the text to extract mission data
                    const missionData = parseMissionFromOCR(text);
                    
                    if (missionData) {
                        // Auto-populate mission
                        addMissionFromOCR(missionData);
                        
                        status.className = 'ocr-status success';
                        status.textContent = `âœ“ Mission extracted! Found: ${missionData.commodities.length} commodity(ies)`;
                    } else {
                        status.className = 'ocr-status error';
                        status.textContent = 'âœ— Could not extract mission data. Try a clearer screenshot.';
                    }
                    
                    uploadArea.classList.remove('processing');
                    
                    // Reset file input
                    event.target.value = '';
                    
                }).catch(err => {
                    console.error('OCR Error:', err);
                    status.className = 'ocr-status error';
                    status.textContent = 'âœ— Error processing image. Please try again.';
                    uploadArea.classList.remove('processing');
                    event.target.value = '';
                });
            };
            
            reader.readAsDataURL(file);
        }

        function parseMissionFromOCR(text) {
            // Enhanced parser for Star Citizen mission screenshots
            const lines = text.split('\n').map(line => line.trim()).filter(line => line);
            
            console.log('=== OCR PARSING START ===');
            console.log('Raw lines:', lines);
            
            const missionData = {
                payout: '',
                commodities: []
            };
            
            const fullText = lines.join(' ');
            
            // Enhanced patterns for Star Citizen UI
            const payoutPattern = /[Â¤#]?\s*([\d,]+)(?:[.,](\d{3}))?/;
            
            // Pattern: "Collect [Commodity] from [Location]"
            // Can include variations like "Collect Quartz (Raw) from Shubin Mining Facility SMCa-6"
            const collectPattern = /collect\s+([\w\s()-]+?)\s+from\s+([\w\s-]+?)(?:\.|$|deliver|on\s+\w|at\s+\w|above\s+\w)/gi;
            
            // Pattern: "Deliver [Quantity] SCU of [Commodity] to [Location]"
            // Handles both "Deliver 28 SCU" and "Deliver 0/28 SCU" (progress format)
            // Stops at common UI text or location suffixes
            const deliverPattern = /deliver\s+(?:\d+\/)?(\d+)\s*SCU\s+of\s+([\w\s()-]+?)\s+to\s+([\w\s-]+?)(?:\s+(?:on|at|above)\s|\.|$|\s+(?:research|outpost|station|depot|facility|spaceport|harbor|workcenter|complex|point|rank|experienced|junior|senior|master|member|rookie))/gi;
            
            // Extract payout
            for (const line of lines) {
                const payoutMatch = line.match(payoutPattern);
                if (payoutMatch && payoutMatch[1]) {
                    const payoutNum = parseInt(payoutMatch[1].replace(/,/g, ''));
                    if (payoutNum > 1000 && !missionData.payout) {
                        if (payoutNum >= 1000) {
                            missionData.payout = (payoutNum / 1000).toFixed(2).replace(/\.?0+$/, '') + 'k';
                        }
                    }
                }
            }
            
            console.log('Extracted payout:', missionData.payout);
            
            // Extract all pickups (Collect X from Y)
            const pickups = {}; // { commodityName: [locations] }
            let collectMatch;
            while ((collectMatch = collectPattern.exec(fullText)) !== null) {
                const commodity = collectMatch[1].trim();
                const location = collectMatch[2].trim();
                
                console.log('Found COLLECT:', commodity, 'from', location);
                
                const cleanedCommodity = cleanCommodityName(commodity);
                const cleanedLocation = cleanLocationName(location);
                
                if (!pickups[cleanedCommodity]) {
                    pickups[cleanedCommodity] = [];
                }
                pickups[cleanedCommodity].push(cleanedLocation);
            }
            
            console.log('All pickups:', pickups);
            
            // Extract all deliveries (Deliver X SCU of Y to Z)
            const deliveries = []; // [{ commodity, quantity, destination }]
            let deliverMatch;
            while ((deliverMatch = deliverPattern.exec(fullText)) !== null) {
                const quantity = deliverMatch[1];
                const commodity = deliverMatch[2].trim();
                const location = deliverMatch[3].trim();
                
                console.log('Found DELIVER:', quantity, 'SCU of', commodity, 'to', location);
                
                deliveries.push({
                    commodity: cleanCommodityName(commodity),
                    quantity: quantity,
                    destination: cleanLocationName(location)
                });
            }
            
            console.log('All deliveries:', deliveries);
            
            // Match pickups with deliveries to create complete commodity entries
            for (const delivery of deliveries) {
                const commodityName = delivery.commodity;
                const pickupLocations = pickups[commodityName] || [];
                
                // Use first pickup location for this commodity (or empty if none found)
                const pickupLocation = pickupLocations[0] || '';
                
                missionData.commodities.push({
                    pickup: pickupLocation,
                    commodity: commodityName,
                    quantity: delivery.quantity,
                    destination: delivery.destination,
                    maxBoxSize: '4'
                });
                
                console.log('Created commodity entry:', {
                    pickup: pickupLocation,
                    commodity: commodityName,
                    quantity: delivery.quantity,
                    destination: delivery.destination
                });
            }
            
            // Return mission data if we found at least one commodity
            if (missionData.commodities.length > 0) {
                console.log('=== SUCCESS: Parsed mission ===', missionData);
                return missionData;
            }
            
            console.log('=== FAILED: No complete commodities found ===');
            return null;
        }
        
        function cleanCommodityName(name) {
            if (!name || !selectedCategory) return name;
            
            // Remove parenthetical suffixes like "(Raw)"
            const baseName = name.replace(/\s*\([^)]+\)\s*$/g, '').trim();
            
            const categoryList = commodities[selectedCategory] || [];
            
            // Try exact match with full name (case insensitive)
            const exactMatch = categoryList.find(c => 
                c.toLowerCase() === name.toLowerCase()
            );
            if (exactMatch) return exactMatch;
            
            // Try exact match with base name (without suffix)
            const exactBaseMatch = categoryList.find(c => 
                c.toLowerCase() === baseName.toLowerCase()
            );
            if (exactBaseMatch) return exactBaseMatch;
            
            // Try partial match with full name
            const partialMatch = categoryList.find(c => 
                name.toLowerCase().includes(c.toLowerCase()) || 
                c.toLowerCase().includes(name.toLowerCase())
            );
            if (partialMatch) return partialMatch;
            
            // Try partial match with base name
            const partialBaseMatch = categoryList.find(c => 
                baseName.toLowerCase().includes(c.toLowerCase()) || 
                c.toLowerCase().includes(baseName.toLowerCase())
            );
            if (partialBaseMatch) return partialBaseMatch;
            
            // Try matching by key words (for compound names like "Hydrogen Fuel")
            const words = baseName.split(/\s+/);
            for (const word of words) {
                if (word.length > 3) { // Only try meaningful words
                    const wordMatch = categoryList.find(c =>
                        c.toLowerCase().includes(word.toLowerCase())
                    );
                    if (wordMatch) return wordMatch;
                }
            }
            
            // If no match found, return original name
            console.log('Warning: Could not match commodity:', name, 'in category:', selectedCategory);
            return name;
        }
        
        function cleanLocationName(name) {
            if (!name || !selectedCategory) return name;
            
            // Remove common suffix phrases that aren't part of the location name
            // Strip: "above X", "on X", "at X's L1 Lagrange point", etc.
            name = name.replace(/\s+(above|on|at)\s+[\w\s'-]+$/gi, '').trim();
            
            // Remove common location type suffixes that might confuse matching
            name = name.replace(/\s+(Research Outpost|Logistics Depot|Depot|Station|Facility|Spaceport|Harbor|Workcenter|Complex|Point)$/gi, '').trim();
            
            const categoryList = locations[selectedCategory] || [];
            
            // Try exact match (case insensitive)
            const exactMatch = categoryList.find(loc => 
                loc.toLowerCase() === name.toLowerCase()
            );
            if (exactMatch) return exactMatch;
            
            // Try partial match (location contains name or name contains location)
            const partialMatch = categoryList.find(loc => {
                const locLower = loc.toLowerCase();
                const nameLower = name.toLowerCase();
                return locLower.includes(nameLower) || nameLower.includes(locLower);
            });
            if (partialMatch) return partialMatch;
            
            // Try matching by location code (e.g., S4LD13, SMCa-6, CRU-L1)
            const codeMatch = name.match(/([A-Z]+[\d-]+[A-Z]*\d*)/i);
            if (codeMatch) {
                const code = codeMatch[1];
                const codePartialMatch = categoryList.find(loc => 
                    loc.toLowerCase().includes(code.toLowerCase())
                );
                if (codePartialMatch) return codePartialMatch;
            }
            
            // Try matching by key words in name
            const words = name.split(/\s+/);
            for (const word of words) {
                if (word.length > 3) { // Only try meaningful words
                    const wordMatch = categoryList.find(loc =>
                        loc.toLowerCase().includes(word.toLowerCase())
                    );
                    if (wordMatch) return wordMatch;
                }
            }
            
            // If no match found, return original cleaned name
            console.log('Warning: Could not match location:', name, 'in category:', selectedCategory);
            return name;
        }

        function addMissionFromOCR(missionData) {
            // Add a new mission panel
            addMissionPanel();
            
            // Get the last added mission
            const lastMission = missions[missions.length - 1];
            const panel = document.getElementById(lastMission.id);
            
            // Set payout
            if (missionData.payout) {
                const payoutSelect = panel.querySelector('select');
                if (payoutSelect) {
                    // Try to find matching payout
                    const options = Array.from(payoutSelect.options);
                    const matchingOption = options.find(opt => opt.value === missionData.payout);
                    if (matchingOption) {
                        payoutSelect.value = missionData.payout;
                        updateMissionPayout(lastMission.id, missionData.payout);
                    }
                }
            }
            
            // Remove default commodity row
            lastMission.commodities = [];
            const commoditiesContainer = document.getElementById(`${lastMission.id}_commodities`);
            commoditiesContainer.innerHTML = '';
            
            // Add commodities from OCR
            missionData.commodities.forEach((commodity, index) => {
                addCommodityRow(lastMission.id);
                
                const commodityData = lastMission.commodities[index];
                const row = document.getElementById(commodityData.id);
                
                // Set values
                const selects = row.querySelectorAll('select');
                const input = row.querySelector('input');
                
                if (selects[0]) selects[0].value = commodity.pickup || '';
                if (selects[1]) selects[1].value = commodity.commodity || '';
                if (input) input.value = commodity.quantity || '';
                if (selects[3]) selects[3].value = commodity.destination || '';
                
                // Update the commodity data
                updateCommodity(commodityData.id, 'pickup', commodity.pickup || '');
                updateCommodity(commodityData.id, 'commodity', commodity.commodity || '');
                updateCommodity(commodityData.id, 'quantity', commodity.quantity || '');
                updateCommodity(commodityData.id, 'destination', commodity.destination || '');
            });
            
            saveSession();
        }

        function handleDragLeave(e) {
            e.target.classList.remove('drag-over');
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            e.preventDefault();

            const dropTarget = e.target.closest('.delivery-location');
            if (draggedElement && dropTarget && draggedElement !== dropTarget) {
                const draggedItem = draggedElement.getAttribute('data-location');
                const targetItem = dropTarget.getAttribute('data-location');
                
                // Determine which order array to use based on current grouping mode
                const orderArray = organizerGroupBy === 'commodity' ? commodityOrder : deliveryOrder;
                
                // Reorder the appropriate array
                const draggedIndex = orderArray.indexOf(draggedItem);
                const targetIndex = orderArray.indexOf(targetItem);
                
                orderArray.splice(draggedIndex, 1);
                orderArray.splice(targetIndex, 0, draggedItem);
                
                // Save order and refresh display
                if (organizerGroupBy === 'commodity') {
                    saveCommodityOrder();
                } else {
                    saveDeliveryOrder();
                }
                // updateDeliverySummary removed
            }

            return false;
        }

        function saveDeliveryOrder() {
            localStorage.setItem('haulerHelperDeliveryOrder', JSON.stringify(deliveryOrder));
        }

        function saveCommodityOrder() {
            localStorage.setItem('haulerHelperCommodityOrder', JSON.stringify(commodityOrder));
        }

        function loadDeliveryOrder() {
            const saved = localStorage.getItem('haulerHelperDeliveryOrder');
            if (saved) {
                try {
                    deliveryOrder = JSON.parse(saved);
                } catch (e) {
                    deliveryOrder = [];
                }
            }
        }

        function loadCommodityOrder() {
            const saved = localStorage.getItem('haulerHelperCommodityOrder');
            if (saved) {
                try {
                    commodityOrder = JSON.parse(saved);
                } catch (e) {
                    commodityOrder = [];
                }
            }
        }



        // Load theme
        function loadTheme() {
            const savedTheme = localStorage.getItem('haulerHelperTheme');
            if (savedTheme) {
                document.body.setAttribute('data-theme', savedTheme);
                document.getElementById('themeSelect').value = savedTheme;
            }
        }

        // Update color palette in picker
        function updateColorPalette() {
            const theme = document.body.getAttribute('data-theme');
            const palette = themeColorPalettes[theme] || themeColorPalettes['stardust'];
            const container = document.getElementById('colorPalette');
            
            container.innerHTML = palette.map(color => 
                `<div class="color-option" style="background-color: ${color}" onclick="selectPresetColor('${color}')"></div>`
            ).join('');
        }

        // Add mission panel
        function addMissionPanel() {
            if (!selectedCategory) {
                alert('Please select a mission category first');
                return;
            }

            missionCounter++;
            const missionId = `mission_${missionCounter}`;
            
            const mission = {
                id: missionId,
                payout: '',
                commodities: []
            };
            
            missions.push(mission);
            
            const container = document.getElementById('missionsContainer');
            const panel = createMissionPanel(missionId, missionCounter);
            container.appendChild(panel);
            
            // Add first commodity row by default
            addCommodityRow(missionId);
            
            saveSession();
        }

        // Create mission panel HTML
        function createMissionPanel(missionId, missionNumber) {
            const panel = document.createElement('div');
            panel.className = 'mission-panel';
            panel.id = missionId;
            
            // Get category-specific payouts
            const category = selectedCategory || 'planetary';
            const categoryPayouts = Array.isArray(payouts) ? payouts : (payouts[category] || payouts.planetary);
            
            panel.innerHTML = `
                <div class="mission-header">
                    <div class="mission-title">Mission ${missionNumber}</div>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <div class="mission-payout">
                            <label>Payout:</label>
                            <select onchange="updateMissionPayout('${missionId}', this.value)">
                                <option value="">-</option>
                                ${categoryPayouts.map(p => `<option value="${p}">${p}</option>`).join('')}
                            </select>
                        </div>
                        <button class="btn-remove-mission" onclick="removeMissionPanel('${missionId}')">Remove</button>
                    </div>
                </div>
                <div id="${missionId}_commodities"></div>
                <button class="btn-add-commodity" onclick="addCommodityRow('${missionId}')">+ Add Commodity</button>
            `;
            
            return panel;
        }

        // Add commodity row
        function addCommodityRow(missionId) {
            const mission = missions.find(m => m.id === missionId);
            if (mission.commodities.length >= 4) {
                alert('Maximum 4 commodities per mission');
                return;
            }
            
            // Get previous commodity for defaults
            const previousCommodity = mission.commodities[mission.commodities.length - 1];
            
            const commodityId = `${missionId}_commodity_${mission.commodities.length}`;
            mission.commodities.push({
                id: commodityId,
                pickup: previousCommodity?.pickup || '',
                commodity: previousCommodity?.commodity || '',
                quantity: '',
                maxBoxSize: previousCommodity?.maxBoxSize || '4',
                destination: previousCommodity?.destination || ''
            });
            
            const container = document.getElementById(`${missionId}_commodities`);
            const row = createCommodityRow(missionId, commodityId, mission.commodities.length > 1);
            container.appendChild(row);
            
            // Set default values in the new row
            const newCommodity = mission.commodities[mission.commodities.length - 1];
            const selects = row.querySelectorAll('select');
            if (selects[0]) selects[0].value = newCommodity.pickup;
            if (selects[1]) selects[1].value = newCommodity.commodity;
            if (selects[2]) selects[2].value = newCommodity.maxBoxSize;
            if (selects[3]) selects[3].value = newCommodity.destination;
            
            saveSession();
        }

        // Create commodity row HTML
        function createCommodityRow(missionId, commodityId, showRemove) {
            const row = document.createElement('div');
            row.className = 'commodity-row';
            row.id = commodityId;
            
            // Get category-specific locations and commodities
            const category = selectedCategory || 'planetary';
            const categoryLocations = locations[category] || locations.planetary;
            const categoryCommodities = Array.isArray(commodities) ? commodities : (commodities[category] || commodities.planetary);
            
            row.innerHTML = `
                <select onchange="updateCommodity('${commodityId}', 'pickup', this.value)">
                    <option value="">Pickup Location</option>
                    ${categoryLocations.map(loc => `<option value="${loc}">${loc}</option>`).join('')}
                </select>
                <select onchange="updateCommodity('${commodityId}', 'commodity', this.value)">
                    <option value="">Commodity</option>
                    ${categoryCommodities.map(c => `<option value="${c}">${c}</option>`).join('')}
                </select>
                <input type="number" placeholder="SCU" min="1" onchange="updateCommodity('${commodityId}', 'quantity', this.value)">
                <select onchange="updateCommodity('${commodityId}', 'maxBoxSize', this.value)">
                    <option value="1">Max: 1 SCU</option>
                    <option value="2">Max: 2 SCU</option>
                    <option value="4">Max: 4 SCU</option>
                    <option value="8">Max: 8 SCU</option>
                    <option value="16">Max: 16 SCU</option>
                    <option value="24">Max: 24 SCU</option>
                    <option value="32">Max: 32 SCU</option>
                </select>
                <select onchange="updateCommodity('${commodityId}', 'destination', this.value)">
                    <option value="">Destination</option>
                    ${categoryLocations.map(loc => `<option value="${loc}">${loc}</option>`).join('')}
                </select>
                ${showRemove ? 
                    `<button class="btn-remove-commodity" onclick="removeCommodityRow('${missionId}', '${commodityId}')">-</button>` :
                    `<div></div>`
                }
            `;
            
            return row;
        }

        // Update commodity data
                function updateCommodity(commodityId, field, value) {
            for (const mission of missions) {
                const commodity = mission.commodities.find(c => c.id === commodityId);
                if (commodity) {
                    commodity[field] = value;
                    
                    // AUTO-FILL PATTERNS: If this is the first commodity and we're setting the commodity name
                    const isFirstCommodity = commodity.id.includes('_commodity_0');
                    const isSettingCommodity = field === 'commodity';
                    const isMicrotech = selectedSystem === 'microtech';
                    
                    if (isFirstCommodity && isSettingCommodity && value && isMicrotech) {
                        applyAutoFillPattern(mission, value);
                    }
                    
                    break;
                }
            }
            generateRoutePlan();
            generateCargoGrid();
            updateStats();
            saveSession();
        }

        // Update mission payout
        function updateMissionPayout(missionId, payout) {
            const mission = missions.find(m => m.id === missionId);
            if (mission) {
                mission.payout = payout;
            }
            updateStats();
            saveSession();
        }

        // AUTO-FILL HELPER FUNCTION
        function applyAutoFillPattern(mission, firstCommodity) {
            // Only apply if mission has exactly 1 commodity (we're setting the first one)
            if (mission.commodities.length !== 1) return;
            
            const depot = 'Covalex S4DC05';
            
            // Define patterns based on first commodity
            const patterns = {
                'Quartz': {
                    destinations: [depot, depot, depot, depot],
                    commodities: ['Quartz', 'Corundum', 'Quartz', 'Corundum']
                },
                'Stims': {
                    pickups: [depot, depot, depot, depot],
                    commodities: ['Stims', 'Stims', 'Stims', 'Stims']
                },
                'Press Ice': {
                    pickups: [depot, depot, depot, depot],
                    commodities: ['Press Ice', 'Press Ice', 'Proc Food', 'Proc Food']
                },
                'Hydrogen Fuel': {
                    pickups: [depot, depot, depot, depot],
                    commodities: ['Hydrogen Fuel', 'Hydrogen Fuel', 'Quantum Fuel', 'Ship Ammo']
                },
                'Waste': {
                    destinations: [depot, depot, depot, depot],
                    commodities: ['Waste', 'Scrap', 'Waste', 'Scrap']
                }
            };
            
            const pattern = patterns[firstCommodity];
            if (!pattern) return; // No pattern for this commodity
            
            console.log(`âœ¨ Auto-filling mission with ${firstCommodity} pattern`);
            
            // Add 3 more commodity rows (we already have 1)
            for (let i = 1; i < 4; i++) {
                if (mission.commodities.length >= 4) break;
                addCommodityRow(mission.id);
            }
            
            // Wait for DOM to update, then fill in values
            setTimeout(() => {
                mission.commodities.forEach((commodity, index) => {
                    if (pattern.pickups) {
                        commodity.pickup = pattern.pickups[index];
                        const pickupSelect = document.querySelector(`#${commodity.id} select:nth-of-type(1)`);
                        if (pickupSelect) pickupSelect.value = pattern.pickups[index];
                    }
                    
                    if (pattern.destinations) {
                        commodity.destination = pattern.destinations[index];
                        const destSelect = document.querySelector(`#${commodity.id} select:nth-of-type(4)`);
                        if (destSelect) destSelect.value = pattern.destinations[index];
                    }
                    
                    commodity.commodity = pattern.commodities[index];
                    const commoditySelect = document.querySelector(`#${commodity.id} select:nth-of-type(2)`);
                    if (commoditySelect) commoditySelect.value = pattern.commodities[index];
                });
                
                // Update displays
                generateRoutePlan();
                generateCargoGrid();
                updateStats();
                saveSession();
            }, 100);
        }

           
        

        // Remove commodity row
        function removeCommodityRow(missionId, commodityId) {
            const mission = missions.find(m => m.id === missionId);
            if (mission) {
                mission.commodities = mission.commodities.filter(c => c.id !== commodityId);
                document.getElementById(commodityId).remove();
            }
            generateRoutePlan();
            generateCargoGrid();
            updateStats();
            saveSession();
        }

        // Remove mission panel
        function removeMissionPanel(missionId) {
            missions = missions.filter(m => m.id !== missionId);
            document.getElementById(missionId).remove();
            generateRoutePlan();
            generateCargoGrid();
            updateStats();
            saveSession();
        }

        // Get inline SVG icon for box sizes (supports currentColor for theming)
        function getBoxIconSVG(size) {
            const svgs = {
                '1': '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="box-icon-svg"><path fill="currentColor" d="M15.88,7.74v8.52h-7.75V7.74h7.75M16.88,6.74H7.12v10.52h9.75V6.74h0Z"/><path fill="currentColor" d="M12.11,9.15h.9v6.01h-1.3v-4.68l-1.04.26-.27-1.08,1.71-.51Z"/></svg>',
                '2': '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="box-icon-svg"><path fill="currentColor" d="M15.88,3.53v16.94h-7.75V3.53h7.75M16.88,2.53H7.12v18.94h9.75V2.53h0Z"/><path fill="currentColor" d="M10.76,11.21l-.92-.74c.59-.8,1.16-1.24,2.23-1.24,1.27,0,2.06.73,2.06,1.85,0,1-.51,1.5-1.57,2.32l-.97.75h2.6v1.13h-4.42v-1.04l1.99-1.63c.74-.61,1.03-.94,1.03-1.43s-.33-.78-.8-.78-.78.26-1.22.8Z"/></svg>',
                '4': '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="box-icon-svg"><path fill="currentColor" d="M20.49,3.53v16.94H3.51V3.53h16.98M21.49,2.53H2.51v18.94h18.98V2.53h0Z"/><path fill="currentColor" d="M13.55,9.53v3.66h.8v1.07h-.8v1.29h-1.25v-1.29h-2.92l-.21-.93,3.28-3.8h1.11ZM12.3,11.33l-1.59,1.86h1.59v-1.86Z"/></svg>',
                '8': '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="box-icon-svg"><path fill="currentColor" d="M11.15,11.38c0-.37.31-.69.85-.69s.85.33.85.7c0,.43-.33.74-.85.74s-.85-.32-.85-.75Z"/><path fill="currentColor" d="M13.03,13.91c0,.43-.38.75-1.03.75s-1.03-.32-1.03-.75c0-.47.43-.74,1.03-.74s1.03.27,1.03.74Z"/><path fill="currentColor" d="M2.51,2.73v18.94h18.98V2.73H2.51ZM12,15.74c-1.32,0-2.3-.68-2.3-1.73,0-.73.33-1.16.96-1.45-.46-.28-.76-.66-.76-1.31,0-.92.84-1.65,2.1-1.65s2.1.73,2.1,1.65c0,.65-.3,1.03-.76,1.31.6.32.96.7.96,1.42,0,1.12-.98,1.76-2.3,1.76Z"/></svg>',
                '16': '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="box-icon-svg"><path fill="currentColor" d="M13.94,12.76c-.65,0-1.03.36-1.03.87s.39.9,1.04.9,1.03-.37,1.03-.89-.4-.88-1.04-.88Z"/><path fill="currentColor" d="M2.51,2.73v18.94h18.98V2.73H2.51ZM3.72,20.37v-4.71l4.7,4.71H3.72ZM10.33,15.55h-1.3v-4.68l-1.04.26-.27-1.08,1.71-.51h.9v6.01ZM14,15.66c-.77,0-1.3-.23-1.72-.64-.43-.44-.71-1.08-.71-2.27,0-1.85.84-3.27,2.62-3.27.81,0,1.34.24,1.87.66l-.69,1.01c-.39-.3-.71-.48-1.22-.48-.74,0-1.12.6-1.2,1.39.3-.2.64-.39,1.23-.39,1.19,0,2.1.66,2.1,1.91s-.98,2.08-2.28,2.08ZM20.18,8.75l-4.7-4.7h4.7v4.7Z"/></svg>',
                '24': '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="box-icon-svg"><path fill="currentColor" d="M2.51,2.73v18.94h18.98V2.73H2.51ZM12,15.74c-1.32,0-2.3-.68-2.3-1.73,0-.73.33-1.16.96-1.45-.46-.28-.76-.66-.76-1.31,0-.92.84-1.65,2.1-1.65s2.1.73,2.1,1.65c0,.65-.3,1.03-.76,1.31.6.32.96.7.96,1.42,0,1.12-.98,1.76-2.3,1.76Z"/></svg>',
                '32': '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="box-icon-svg"><path fill="currentColor" d="M2.51,2.54v18.94h18.98V2.54H2.51ZM3.84,3.75h4.7l-4.7,4.7V3.75ZM3.77,20.17v-4.7l4.7,4.7H3.77ZM9.34,15.11c-1.07,0-1.81-.43-2.33-1.03l.9-.87c.42.46.83.72,1.44.72.49,0,.85-.28.85-.73,0-.5-.42-.77-1.17-.77h-.55l-.2-.84,1.43-1.43h-2.36v-1.13h4.05v.99l-1.51,1.44c.82.14,1.59.57,1.59,1.69s-.82,1.96-2.14,1.96ZM12.41,13.96l1.98-1.62c.73-.62,1.02-.94,1.02-1.44s-.32-.77-.8-.77c-.45,0-.77.25-1.21.8l-.93-.74c.6-.81,1.17-1.24,2.24-1.24,1.26,0,2.05.73,2.05,1.85,0,1-.52,1.5-1.58,2.32l-.96.75h2.6v1.14h-4.41v-1.05ZM20.16,20.21h-4.7l4.7-4.7v4.7ZM20.23,8.56l-4.7-4.71h4.7v4.71Z"/></svg>'
            };
            return svgs[size] || svgs['4']; // Default to 4 if size not found
        }

        // Calculate box breakdown
        function calculateBoxBreakdown(scu, maxBoxSize = 32) {
            const allBoxSizes = [32, 24, 16, 8, 4, 2, 1];
            const boxSizes = allBoxSizes.filter(size => size <= maxBoxSize);
            const breakdown = {};
            let remaining = scu;
            
            for (const size of boxSizes) {
                const count = Math.floor(remaining / size);
                if (count > 0) {
                    breakdown[size] = count;
                    remaining -= size * count;
                }
            }
            
            return breakdown;
        }

        // Update delivery summary

        // Group deliveries by location

        // Tab switching function
        function switchDeliveryTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.style.display = 'none';
            });
            
            // Remove active class from all buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab and activate button
            if (tabName === 'route') {
                document.getElementById('routeTab').style.display = 'block';
            } else if (tabName === 'grid') {
                document.getElementById('gridTab').style.display = 'block';
            }
            
            // Activate the clicked button
            event.target.classList.add('active');
        }

        // Generate optimized route plan
        // Update cargo grid layout based on columns and rows dropdowns
        function updateGridLayout() {
            const cols = parseInt(document.getElementById('gridColumns').value);
            const rows = parseInt(document.getElementById('gridRows').value);
            
            cargoGridLayout = {cols: cols, rows: rows};
            localStorage.setItem('haulerHelperCargoGridLayout', JSON.stringify(cargoGridLayout));
            
            generateCargoGrid();
        }

        // Load cargo grid layout preference
        function loadCargoGridLayout() {
            const saved = localStorage.getItem('haulerHelperCargoGridLayout');
            if (saved) {
                try {
                    cargoGridLayout = JSON.parse(saved);
                    document.getElementById('gridColumns').value = cargoGridLayout.cols || 3;
                    document.getElementById('gridRows').value = cargoGridLayout.rows || 3;
                } catch (e) {
                    cargoGridLayout = {cols: 3, rows: 3};
                }
            } else {
                cargoGridLayout = {cols: 3, rows: 3};
            }
        }

        // Generate cargo grid with free positioning
        function generateCargoGrid() {
            const container = document.getElementById('cargoGrid');
            
            if (!container) {
                console.error('âŒ cargoGrid container not found!');
                return;
            }
            
            // Get cargo groups from missions
            const groupData = {};
            
            missions.forEach((mission, missionIndex) => {
                mission.commodities.forEach(commodity => {
                    if (!commodity.pickup || !commodity.destination || !commodity.commodity || !commodity.quantity) {
                        return;
                    }
                    
                    const scu = parseInt(commodity.quantity) || 0;
                    const destination = commodity.destination;
                    
                    if (!groupData[destination]) {
                        groupData[destination] = {
                            destination: destination,
                            totalSCU: 0,
                            items: []
                        };
                    }
                    
                    groupData[destination].totalSCU += scu;
                    groupData[destination].items.push({
                        missionNum: missionIndex + 1,
                        commodity: commodity.commodity,
                        scu: scu,
                        pickup: commodity.pickup,
                        maxBoxSize: parseInt(commodity.maxBoxSize) || 4
                    });
                });
            });
            
            if (Object.keys(groupData).length === 0) {
                container.innerHTML = '<div class="empty-state">No cargo groups to display</div>';
                container.style.gridTemplateColumns = 'repeat(2, 1fr)';
                return;
            }
            
            // Assign colors and labels to groups
            const theme = document.body.getAttribute('data-theme');
            const palette = themeColorPalettes[theme] || themeColorPalettes['stardust'];
            let groupIndex = Object.keys(cargoGroups).length; // Start from existing count
            
            Object.keys(groupData).forEach(destination => {
                if (!cargoGroups[destination]) {
                    const groupLetter = String.fromCharCode(65 + groupIndex);
                    cargoGroups[destination] = {
                        label: groupLetter,
                        color: palette[groupIndex % palette.length],
                        position: null  // Will be set by user
                    };
                    groupIndex++;
                }
            });
            
            // Calculate grid dimensions
            const cols = cargoGridLayout.cols || 3;
            const rows = cargoGridLayout.rows || 3;
            const totalCells = rows * cols;
            
            // Build grid with positioned groups
            container.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            
            // Create array of cells
            const cells = [];
            for (let i = 0; i < totalCells; i++) {
                cells.push({ position: i, group: null });
            }
            
            // Place groups in their positions (or auto-place if no position set)
            let autoPosition = 0;
            Object.keys(groupData).forEach(destination => {
                const group = cargoGroups[destination];
                const data = groupData[destination];
                
                // Use saved position or auto-place
                let position = group.position;
                if (position === null || position === undefined || position >= totalCells) {
                    // Auto-place in next available spot
                    while (autoPosition < totalCells && cells[autoPosition].group !== null) {
                        autoPosition++;
                    }
                    position = autoPosition;
                    group.position = position;
                }
                
                if (position < totalCells) {
                    cells[position].group = {
                        destination: destination,
                        ...data,
                        ...group
                    };
                }
            });
            
            // Render grid
            container.innerHTML = cells.map((cell, index) => {
                if (!cell.group) {
                    // Empty cell - drop target
                    return `
                        <div class="cargo-group-cell empty-cell" 
                             data-position="${index}">
                        </div>
                    `;
                }
                
                const g = cell.group;
                return `
                    <div class="cargo-group-card" 
                         data-destination="${g.destination}"
                         data-position="${index}"
                         style="border-color: ${g.color}"
                         draggable="true">
                        <div class="cargo-group-header">
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <div class="cargo-drag-handle" title="Drag to reposition">â‹®â‹®</div>
                                <div class="cargo-group-label-edit" 
                                     style="color: ${g.color}; cursor: pointer; pointer-events: auto;"
                                     onclick="event.stopPropagation(); editCargoGroupLabel('${g.destination}', event)">
                                    ${g.label}
                                </div>
                            </div>
                            <div class="cargo-group-scu">${g.totalSCU} SCU</div>
                        </div>
                        <div class="cargo-group-color-edit"
                             style="background-color: ${g.color}; width: 30px; height: 30px; border-radius: 4px; cursor: pointer; margin: 8px 0;"
                             onclick="event.stopPropagation(); editCargoGroupColor('${g.destination}')">
                        </div>
                        <div class="cargo-group-destination">${g.destination}</div>
                        <div class="expand-indicator" onclick="event.stopPropagation(); toggleCargoGroupExpand(this.parentElement)">Click to expand</div>
                        <div class="cargo-group-details">
                            ${g.items.map(item => {
                                const boxes = calculateBoxBreakdown(item.scu, item.maxBoxSize);
                                return `
                                    <div class="cargo-group-details-item">
                                        <span class="mission-num">Mission ${item.missionNum}:</span>
                                        <span class="commodity">${item.commodity}</span>
                                        <span>(${item.scu} SCU)</span>
                                    </div>
                                    <div class="box-breakdown" style="padding-left: 10px; margin-bottom: 8px;">
                                        ${Object.entries(boxes).map(([size, count]) => `
                                            <div class="box-icon">
                                                ${getBoxIconSVG(size)}
                                                <span class="box-count">Ã— ${count}</span>
                                            </div>
                                        `).join('')}
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            }).join('');
            
            // Attach drag handlers and apply expanded state after rendering
            setTimeout(() => {
                attachCargoGridDragHandlers();
                
                // Apply expanded state to all cards
                if (cargoGridExpanded) {
                    document.querySelectorAll('.cargo-group-card').forEach(card => {
                        card.classList.add('expanded');
                    });
                }
                
                console.log('âœ… Cargo grid rendering complete');
            }, 0);
        }

        // Edit cargo group label
        function editCargoGroupLabel(destination, event) {
            event.stopPropagation();
            const newLabel = prompt('Enter new label for this cargo group:', cargoGroups[destination].label);
            if (newLabel !== null && newLabel.trim() !== '') {
                cargoGroups[destination].label = newLabel.trim();
                generateCargoGrid();
                generateRoutePlan(); // Update route planner too
                saveSession();
            }
        }

        // Edit cargo group color
        function editCargoGroupColor(destination) {
            currentColorTarget = destination;
            const modal = document.getElementById('colorPickerModal');
            modal.classList.add('active');
            
            const currentColor = cargoGroups[destination].color;
            document.getElementById('customColorInput').value = currentColor;
        }




        // DIAGNOSTIC: Check actual DOM state
        window.diagnoseCargoGrid = function() {
            const cards = document.querySelectorAll('.cargo-group-card');
            console.log('=== CARGO GRID DIAGNOSTICS ===');
            console.log('Found cards:', cards.length);
            
            cards.forEach((card, i) => {
                console.log(`Card ${i}:`, {
                    draggable: card.draggable,
                    hasAttribute: card.hasAttribute('draggable'),
                    getAttribute: card.getAttribute('draggable'),
                    ondragstart: card.ondragstart,
                    destination: card.getAttribute('data-destination'),
                    classList: Array.from(card.classList),
                    computedStyle: {
                        pointerEvents: getComputedStyle(card).pointerEvents,
                        userDrag: getComputedStyle(card).webkitUserDrag || getComputedStyle(card).userDrag
                    }
                });
                
                // Check first child (drag handle)
                const dragHandle = card.querySelector('.cargo-drag-handle');
                if (dragHandle) {
                    console.log('  Drag handle:', {
                        computedStyle: {
                            pointerEvents: getComputedStyle(dragHandle).pointerEvents
                        }
                    });
                }
            });
            
            console.log('=== END DIAGNOSTICS ===');
        };

        // TEST FUNCTION - User can call this from console
        window.testDragStart = function() {
            console.log('ðŸ§ª Testing if handleCargoGridDragStart exists:', typeof handleCargoGridDragStart);
            console.log('ðŸ§ª Testing draggedCargoGroup:', draggedCargoGroup);
            console.log('ðŸ§ª Testing cargoGroups:', cargoGroups);
        };


        // Attach drag handlers to all cargo cards after grid generation
        function attachCargoGridDragHandlers() {
            const cards = document.querySelectorAll('.cargo-group-card');
            
            cards.forEach(card => {
                // Remove any existing handlers first
                card.ondragstart = null;
                card.ondragend = null;
                card.ondragover = null;
                card.ondrop = null;
                
                // Attach new handlers (though document-level handlers will catch them)
                card.addEventListener('dragstart', handleCargoGridDragStart, false);
                card.addEventListener('dragend', handleCargoGridDragEnd, false);
                card.addEventListener('dragover', handleCargoGridDragOver, false);
                card.addEventListener('drop', handleCargoGridDrop, false);
            });
            
            // Also attach to empty cells
            const emptyCells = document.querySelectorAll('.empty-cell');
            
            emptyCells.forEach(cell => {
                cell.ondragover = null;
                cell.ondrop = null;
                cell.addEventListener('dragover', handleCargoGridDragOver, false);
                cell.addEventListener('drop', handleCargoGridDrop, false);
            });
        }

        // Cargo grid drag and drop handlers
        let draggedCargoGroup = null;
        let cargoGridExpanded = false; // Track if cargo grid cards are expanded
        let routeStops = []; // Store current route stops for reordering

        function handleCargoGridDragStart(e) {
            // When called from document listener, use e.target instead of e.currentTarget
            const cardElement = e.currentTarget === document ? e.target : e.currentTarget;
            
            draggedCargoGroup = cardElement.getAttribute('data-destination');
            console.log('ðŸ”µ Drag start:', draggedCargoGroup);
            
            if (!draggedCargoGroup) {
                console.log('âŒ No destination attribute found!');
                return;
            }
            
            cardElement.style.opacity = '0.5';
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', draggedCargoGroup);
        }

        function handleCargoGridDragEnd(e) {
            const cardElement = e.currentTarget === document ? e.target : e.currentTarget;
            cardElement.style.opacity = '1';
            console.log('ðŸ”´ DRAG END');
        }

        function handleCargoGridDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleCargoGridDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            
            console.log('ðŸŸ¢ DROP EVENT FIRED');
            
            if (!draggedCargoGroup) {
                console.log('âŒ No dragged group!');
                return false;
            }
            
            const target = e.currentTarget === document ? e.target : e.currentTarget;
            const targetPosition = parseInt(target.getAttribute('data-position'));
            const targetDestination = target.getAttribute('data-destination');
            
            console.log('ðŸŽ¯ DROP TARGET:', {
                targetPosition,
                targetDestination,
                draggedGroup: draggedCargoGroup,
                draggedPosition: cargoGroups[draggedCargoGroup]?.position
            });
            
            // Get dragged item's current position
            const draggedPosition = cargoGroups[draggedCargoGroup].position;
            
            if (targetDestination && targetDestination !== draggedCargoGroup) {
                // Swap positions with another card
                console.log('ðŸ”„ SWAPPING:', draggedCargoGroup, 'â†”ï¸', targetDestination);
                const temp = cargoGroups[targetDestination].position;
                cargoGroups[targetDestination].position = draggedPosition;
                cargoGroups[draggedCargoGroup].position = targetPosition;
            } else if (!targetDestination) {
                // Drop on empty cell - just move
                console.log('ðŸ“¦ MOVING to empty cell:', targetPosition);
                cargoGroups[draggedCargoGroup].position = targetPosition;
            } else {
                console.log('âš ï¸ Dropped on self, no action');
            }
            
            // Regenerate grid and save
            console.log('â™»ï¸ Regenerating grid...');
            generateCargoGrid();
            saveSession();
            
            draggedCargoGroup = null;
            return false;
        }

        // Toggle cargo group expansion
        function toggleCargoGroupExpand(card) {
            // Toggle the global expanded state
            cargoGridExpanded = !cargoGridExpanded;
            
            // Apply to all cards
            document.querySelectorAll('.cargo-group-card').forEach(c => {
                if (cargoGridExpanded) {
                    c.classList.add('expanded');
                } else {
                    c.classList.remove('expanded');
                }
            });
            
            // Save state
            localStorage.setItem('haulerHelperCargoGridExpanded', cargoGridExpanded);
        }

        // Update confirmColor to handle cargo groups
        function confirmColor() {
            if (currentColorTarget) {
                const color = document.getElementById('customColorInput').value;
                
                // Check if it's a cargo group or location marker
                if (cargoGroups[currentColorTarget]) {
                    cargoGroups[currentColorTarget].color = color;
                    generateCargoGrid();
                    generateRoutePlan(); // Update route planner colors too
                } else if (locationColors[currentColorTarget]) {
                    locationColors[currentColorTarget].color = color;
                    // updateDeliverySummary removed
                }
                
                saveSession();
            }
            closeColorPicker();
        }




        // Route planner drag and drop handlers
        let draggedRouteStop = null;
        
        function handleRouteStopDragStart(e) {
            const stopElement = e.currentTarget === document ? e.target : e.currentTarget;
            draggedRouteStop = parseInt(stopElement.getAttribute('data-stop-index'));
            console.log('ðŸ”µ Dragging route stop:', draggedRouteStop);
            stopElement.style.opacity = '0.5';
            e.dataTransfer.effectAllowed = 'move';
        }
        
        function handleRouteStopDragEnd(e) {
            const stopElement = e.currentTarget === document ? e.target : e.currentTarget;
            stopElement.style.opacity = '1';
            draggedRouteStop = null;
        }
        
        function handleRouteStopDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            return false;
        }
        
        function handleRouteStopDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            e.preventDefault();
            
            if (draggedRouteStop === null) return false;
            
            const targetElement = e.currentTarget === document ? e.target : e.currentTarget;
            const targetStop = targetElement.closest('.route-stop');
            if (!targetStop) return false;
            
            const targetIndex = parseInt(targetStop.getAttribute('data-stop-index'));
            
            if (draggedRouteStop === targetIndex) return false;
            
            console.log('ðŸ”„ Swapping stops:', draggedRouteStop, 'â†”ï¸', targetIndex);
            
            // Swap stops in array
            const temp = routeStops[draggedRouteStop];
            routeStops[draggedRouteStop] = routeStops[targetIndex];
            routeStops[targetIndex] = temp;
            
            // Re-render with new order
            renderRoutePlan(routeStops);
            
            return false;
        }

        function generateRoutePlan() {
            const container = document.getElementById('routePlanner');
            
            console.log('');
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('ðŸš€ STARTING ROUTE GENERATION');
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            
            // Build comprehensive location map
            const locationMap = {}; // { location: { pickups: [], deliveries: [] } }
            
            missions.forEach((mission, missionIndex) => {
                mission.commodities.forEach(commodity => {
                    if (!commodity.pickup || !commodity.destination || !commodity.commodity || !commodity.quantity) {
                        return;
                    }
                    
                    const scu = parseInt(commodity.quantity) || 0;
                    const pickup = commodity.pickup;
                    const destination = commodity.destination;
                    
                    // Initialize location entries
                    if (!locationMap[pickup]) locationMap[pickup] = { pickups: [], deliveries: [] };
                    if (!locationMap[destination]) locationMap[destination] = { pickups: [], deliveries: [] };
                    
                    // Add pickup action
                    locationMap[pickup].pickups.push({
                        missionNum: missionIndex + 1,
                        commodity: commodity.commodity,
                        scu: scu,
                        destination: destination,
                        maxBoxSize: parseInt(commodity.maxBoxSize) || 4,
                        id: `m${missionIndex + 1}-${commodity.commodity}-${destination}` // Unique ID
                    });
                    
                    // Add delivery action
                    locationMap[destination].deliveries.push({
                        missionNum: missionIndex + 1,
                        commodity: commodity.commodity,
                        scu: scu,
                        pickup: pickup,
                        id: `m${missionIndex + 1}-${commodity.commodity}-${destination}` // Same ID as pickup
                    });
                });
            });
            
            if (Object.keys(locationMap).length === 0) {
                container.innerHTML = '<div class="empty-state">No route planned</div>';
                console.log('âŒ No locations in map - aborting route generation');
                return;
            }
            
            // DEBUG: Show location map contents
            console.log('ðŸ“‹ LOCATION MAP BUILT:');
            Object.entries(locationMap).forEach(([loc, data]) => {
                const pickupSCU = data.pickups.reduce((s, p) => s + p.scu, 0);
                const deliverySCU = data.deliveries.reduce((s, d) => s + d.scu, 0);
                console.log(`  ${loc}:`);
                if (data.pickups.length > 0) {
                    console.log(`    ðŸ“¦ Pickups: ${pickupSCU} SCU (${data.pickups.length} items)`);
                    data.pickups.forEach(p => {
                        console.log(`       - Mission ${p.missionNum}: ${p.commodity} ${p.scu} SCU â†’ ${p.destination}`);
                    });
                }
                if (data.deliveries.length > 0) {
                    console.log(`    ðŸ“­ Deliveries: ${deliverySCU} SCU (${data.deliveries.length} items)`);
                    data.deliveries.forEach(d => {
                        console.log(`       - Mission ${d.missionNum}: ${d.commodity} ${d.scu} SCU from ${d.pickup}`);
                    });
                }
            });
            console.log('');
            
            // Assign colors to cargo groups (by destination)
            const theme = document.body.getAttribute('data-theme');
            const palette = themeColorPalettes[theme] || themeColorPalettes['stardust'];
            let groupIndex = Object.keys(cargoGroups).length; // Start from existing count
            
            // Assign groups for each destination
            Object.keys(locationMap).forEach(location => {
                if (locationMap[location].pickups.length > 0) {
                    locationMap[location].pickups.forEach(pickup => {
                        if (!cargoGroups[pickup.destination]) {
                            const groupLetter = String.fromCharCode(65 + groupIndex);
                            cargoGroups[pickup.destination] = {
                                label: groupLetter,
                                color: palette[groupIndex % palette.length]
                            };
                            groupIndex++;
                        }
                    });
                }
            });
            
                        // Build optimized route - ENHANCED with route solver fixes
            const stops = [];
            const cargoOnBoard = new Set(); // Track IDs of cargo currently on ship
            const allPickupIds = new Set();
            const allDeliveryIds = new Set();
            
            // Collect all pickup and delivery IDs
            Object.values(locationMap).forEach(loc => {
                loc.pickups.forEach(p => allPickupIds.add(p.id));
                loc.deliveries.forEach(d => allDeliveryIds.add(d.id));
            });
            
            let currentCargo = 0;
            const shipCapacity = selectedShip ? selectedShip.capacity : 999999;
            
            // FIX #1: Calculate warehouse pickup totals and identify primary warehouse (largest pickup)
            const warehousePickupTotals = {};
            Object.entries(locationMap).forEach(([loc, data]) => {
                const totalPickup = data.pickups.reduce((s, p) => s + p.scu, 0);
                if (totalPickup > 0) {
                    warehousePickupTotals[loc] = totalPickup;
                }
            });
            
            const primaryWarehouse = Object.entries(warehousePickupTotals)
                .sort((a, b) => b[1] - a[1])[0]?.[0];
            
            console.log('ðŸ­ WAREHOUSE IDENTIFICATION:');
            console.log('  Warehouse pickup totals:', warehousePickupTotals);
            console.log(`  Primary warehouse: ${primaryWarehouse} (${warehousePickupTotals[primaryWarehouse]} SCU)`);
            console.log('');
            
            // Keep visiting locations until everything is delivered
            let iteration = 0;
            while (allDeliveryIds.size > 0 || allPickupIds.size > 0) {
                iteration++;
                console.log(`\nâ”â”â” ITERATION ${iteration} â”â”â”`);
                console.log(`Cargo on board: ${currentCargo} SCU`);
                console.log(`Pickups remaining: ${allPickupIds.size}`);
                console.log(`Deliveries remaining: ${allDeliveryIds.size}`);
                console.log(`Stops so far: ${stops.map(s => s.location).join(' â†’ ')}`);
                console.log('');
                let bestLocation = null;
                let bestScore = -1;
                
                // FIX #1 (continued): Force first stop to be the largest pickup warehouse
                if (primaryWarehouse && 
                    stops.length === 0 && 
                    locationMap[primaryWarehouse].pickups.some(p => allPickupIds.has(p.id))) {
                    bestLocation = primaryWarehouse;
                    console.log('âœ… Forcing first stop to primary warehouse:', primaryWarehouse);
                } else {
                    // Find the best next location to visit
                    console.log('ðŸ” EVALUATING LOCATIONS:');
                    for (const location of Object.keys(locationMap)) {
                        const hasUnpickedCargo = locationMap[location].pickups.some(p => allPickupIds.has(p.id));
                        const hasReadyDeliveries = locationMap[location].deliveries.some(d => cargoOnBoard.has(d.id));
                        
                        console.log(`  ${location}:`);
                        console.log(`    - Has unpicked cargo: ${hasUnpickedCargo}`);
                        console.log(`    - Has ready deliveries: ${hasReadyDeliveries}`);
                        
                        if (!hasUnpickedCargo && !hasReadyDeliveries) {
                            console.log(`    â­ï¸  SKIP: Nothing to do here`);
                            continue;
                        }
                        
                        // FIX #2: Block return-to-warehouse until end
                        const isWarehouse = location === primaryWarehouse;
                        const hasDeliveriesHere = locationMap[location].deliveries.some(d => cargoOnBoard.has(d.id));
                        
                        console.log(`    - Is primary warehouse: ${isWarehouse}`);
                        
                        // Block warehouse deliveries if there are ANY other non-warehouse deliveries pending
                        if (isWarehouse && hasDeliveriesHere && !hasUnpickedCargo) {
                            console.log(`    ðŸ”’ WAREHOUSE RETURN CHECK:`);
                            // Count how many non-warehouse deliveries are still pending
                            let otherDeliveriesCount = 0;
                            for (const [loc, data] of Object.entries(locationMap)) {
                                if (loc !== primaryWarehouse) {
                                    const pendingHere = data.deliveries.filter(d => allDeliveryIds.has(d.id)).length;
                                    if (pendingHere > 0) {
                                        console.log(`       - ${loc}: ${pendingHere} pending deliveries`);
                                    }
                                    otherDeliveriesCount += pendingHere;
                                }
                            }
                            
                            if (otherDeliveriesCount > 0) {
                                console.log(`    ðŸš« BLOCKED: ${otherDeliveriesCount} other deliveries still pending`);
                                continue; // Skip warehouse for now
                            } else {
                                console.log(`    âœ… ALLOWED: All other deliveries complete`);
                            }
                        }
                        
                        // FIX #3: Score by actual SCU, not just presence
                        const deliverySCU = locationMap[location].deliveries
                            .filter(d => cargoOnBoard.has(d.id))
                            .reduce((s, d) => s + d.scu, 0);
                        
                        const pickupSCU = locationMap[location].pickups
                            .filter(p => allPickupIds.has(p.id))
                            .reduce((s, p) => s + p.scu, 0);
                        
                        let score = 0;
                        const deliveryScore = deliverySCU * 3;
                        const pickupScore = pickupSCU * 2;
                        const comboBonus = (deliverySCU > 0 && pickupSCU > 0) ? 200 : 0;
                        
                        score = deliveryScore + pickupScore + comboBonus;
                        
                        console.log(`    ðŸ“Š SCORING:`);
                        console.log(`       - Delivery: ${deliverySCU} SCU Ã— 3 = ${deliveryScore}`);
                        console.log(`       - Pickup: ${pickupSCU} SCU Ã— 2 = ${pickupScore}`);
                        console.log(`       - Combo bonus: ${comboBonus}`);
                        console.log(`       - TOTAL SCORE: ${score}`);
                        
                        if (score > bestScore) {
                            console.log(`    â­ NEW BEST LOCATION!`);
                            bestScore = score;
                            bestLocation = location;
                        }
                    }
                }
                
                if (!bestLocation) {
                    console.error('âŒ Route planner: No valid next location found');
                    console.log('   Final state:');
                    console.log(`   - Pickups remaining: ${allPickupIds.size}`);
                    console.log(`   - Deliveries remaining: ${allDeliveryIds.size}`);
                    console.log(`   - Cargo on board IDs:`, Array.from(cargoOnBoard));
                    break; // Safety check
                }
                
                console.log(`\nâœ… SELECTED: ${bestLocation} (score: ${bestScore})`);
                
                // Visit this location and do ALL possible actions in ONE stop
                const loc = locationMap[bestLocation];
                const pickupsHere = loc.pickups.filter(p => allPickupIds.has(p.id));
                const deliveriesHere = loc.deliveries.filter(d => cargoOnBoard.has(d.id));
                
                if (pickupsHere.length === 0 && deliveriesHere.length === 0) {
                    console.error('âŒ Route planner: Selected location has no valid actions');
                    break;
                }
                
                const deliverySCU = deliveriesHere.reduce((sum, d) => sum + d.scu, 0);
                const pickupSCU = pickupsHere.reduce((sum, p) => sum + p.scu, 0);
                
                console.log(`ðŸ“ STOP ${stops.length + 1}: ${bestLocation}`);
                if (deliveriesHere.length > 0) {
                    console.log(`   ðŸ“­ Delivering ${deliverySCU} SCU:`);
                    deliveriesHere.forEach(d => {
                        console.log(`      - Mission ${d.missionNum}: ${d.commodity} ${d.scu} SCU`);
                    });
                }
                if (pickupsHere.length > 0) {
                    console.log(`   ðŸ“¦ Picking up ${pickupSCU} SCU:`);
                    pickupsHere.forEach(p => {
                        console.log(`      - Mission ${p.missionNum}: ${p.commodity} ${p.scu} SCU â†’ ${p.destination}`);
                    });
                }
                console.log(`   Cargo: ${currentCargo} â†’ ${currentCargo - deliverySCU + pickupSCU} SCU`);
                
                // Record this stop (with both pickups AND deliveries)
                stops.push({
                    location: bestLocation,
                    pickups: pickupsHere,
                    deliveries: deliveriesHere,
                    cargoBeforeStop: currentCargo,
                    cargoAfterStop: currentCargo - deliverySCU + pickupSCU
                });
                
                // Update cargo state - deliveries first (free space), then pickups
                deliveriesHere.forEach(d => {
                    cargoOnBoard.delete(d.id);
                    allDeliveryIds.delete(d.id);
                });
                
                pickupsHere.forEach(p => {
                    cargoOnBoard.add(p.id);
                    allPickupIds.delete(p.id);
                });
                
                currentCargo = currentCargo - deliverySCU + pickupSCU;
            }
            
            console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('âœ… ROUTE GENERATION COMPLETE');
            console.log(`Total stops: ${stops.length}`);
            console.log(`Route: ${stops.map(s => s.location).join(' â†’ ')}`);
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
            
            // Store stops and render
            routeStops = stops;
            renderRoutePlan(stops);
        }
        
        // Render route plan (separated so we can re-render after drag)
        function renderRoutePlan(stops) {
            const container = document.getElementById('routePlanner');
            const shipCapacity = selectedShip ? selectedShip.capacity : 999999;
            
            // Recalculate cargo levels based on current order
            let currentCargo = 0;
            stops.forEach(stop => {
                stop.cargoBeforeStop = currentCargo;
                const pickupSCU = stop.pickups.reduce((sum, p) => sum + p.scu, 0);
                const deliverySCU = stop.deliveries.reduce((sum, d) => sum + d.scu, 0);
                currentCargo = currentCargo - deliverySCU + pickupSCU;
                stop.cargoAfterStop = currentCargo;
            });
            
            container.innerHTML = `
                <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 20px; text-transform: uppercase; letter-spacing: 1px;">
                    Optimized Route - ${stops.length} Stops
                </div>
                ${stops.map((stop, index) => {
                    const hasPickups = stop.pickups.length > 0;
                    const hasDeliveries = stop.deliveries.length > 0;
                    
                    return `
                        <div class="route-stop" data-stop-index="${index}" draggable="true">
                            <div class="route-stop-header">
                                <div class="route-stop-title">Stop ${index + 1}: ${stop.location}</div>
                                <div class="route-cargo-status">Cargo: ${stop.cargoAfterStop}/${selectedShip ? shipCapacity : '--'} SCU</div>
                            </div>
                            
                            ${hasDeliveries ? `
                                <div class="route-action-section">
                                    <div class="route-action-header" style="color: var(--color-success);">
                                        <span style="font-size: 16px; margin-right: 8px;">â–¼</span> DELIVERY
                                    </div>
                                    ${stop.deliveries.map(item => {
                                        const group = cargoGroups[stop.location];
                                        return `
                                            <div class="route-mission-item" style="border-left: 3px solid ${group?.color || '#888'}; padding-left: 12px; margin-left: 20px;">
                                                <span class="mission-number">Mission ${item.missionNum}:</span>
                                                <span class="commodity">${item.commodity}</span>
                                                <span>(${item.scu} SCU)</span>
                                                <span style="color: ${group?.color || '#888'}; font-weight: 600; margin-left: 8px;">Group ${group?.label || '?'}</span>
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            ` : ''}
                            
                            ${hasPickups ? `
                                <div class="route-action-section">
                                    <div class="route-action-header" style="color: var(--color-warning);">
                                        <span style="font-size: 16px; margin-right: 8px;">â–²</span> PICKUP
                                    </div>
                                    ${stop.pickups.map(item => {
                                        const group = cargoGroups[item.destination];
                                        return `
                                            <div class="route-mission-item" style="border-left: 3px solid ${group?.color || '#888'}; padding-left: 12px; margin-left: 20px;">
                                                <span class="mission-number">Mission ${item.missionNum}:</span>
                                                <span class="commodity">${item.commodity}</span>
                                                <span>(${item.scu} SCU)</span>
                                                <span style="color: ${group?.color || '#888'}; font-weight: 600; margin-left: 8px;">â†’ Group ${group?.label || '?'}</span>
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            ` : ''}
                        </div>
                    `;
                }).join('')}
            `;
        }





        // Group deliveries by commodity

        // Update stats
        function updateStats() {
            // Calculate total payout
            let totalPayout = 0;
            missions.forEach(mission => {
                if (mission.payout) {
                    totalPayout += parseInt(mission.payout.replace('k', '')) * 1000;
                }
            });
            
            // Format with commas
            const payoutFormatted = totalPayout.toLocaleString('en-US');
            document.getElementById('totalPayout').textContent = payoutFormatted;
            
            // Calculate total SCU
            let totalSCU = 0;
            missions.forEach(mission => {
                mission.commodities.forEach(commodity => {
                    if (commodity.quantity) {
                        totalSCU += parseInt(commodity.quantity) || 0;
                    }
                });
            });
            
            document.getElementById('scuTotal').textContent = totalSCU;
            
            // Update capacity meter
            if (selectedShip) {
                const percentage = Math.min((totalSCU / selectedShip.capacity) * 100, 100);
                const fill = document.getElementById('capacityFill');
                fill.style.width = percentage + '%';
                
                if (totalSCU > selectedShip.capacity) {
                    fill.classList.add('over-capacity');
                } else {
                    fill.classList.remove('over-capacity');
                }
                
                document.getElementById('capacityText').textContent = 
                    `${totalSCU} / ${selectedShip.capacity} SCU`;
            } else {
                document.getElementById('capacityText').textContent = '0 / 0 SCU';
                document.getElementById('capacityFill').style.width = '0%';
            }
        }

        // Color picker functions
        function openColorPicker(location) {
            currentColorTarget = location;
            const modal = document.getElementById('colorPickerModal');
            modal.classList.add('active');
            
            const currentColor = locationColors[location].color;
            document.getElementById('customColorInput').value = currentColor;
        }

        function closeColorPicker() {
            document.getElementById('colorPickerModal').classList.remove('active');
            currentColorTarget = null;
        }

        function selectPresetColor(color) {
            document.getElementById('customColorInput').value = color;
        }



        function updateMarkerLabel(location, label) {
            locationColors[location].label = label;
            saveSession();
        }

        // Session management
        function saveSession() {
            if (isLoadingSession) {
                console.log('â¸ï¸ Skipping save - currently loading session');
                return;
            }
            
            console.log('ðŸ’¾ saveSession() called! Current state:', {
                ship: selectedShip?.id,
                system: selectedSystem,
                category: selectedCategory,
                missionsCount: missions.length
            });
            const session = {
                ship: selectedShip?.id,
                system: selectedSystem,
                category: selectedCategory,
                missions: missions,
                locationColors: locationColors,
                cargoGroups: cargoGroups,
                timestamp: new Date().toISOString()
            };
            localStorage.setItem('haulerHelperSession', JSON.stringify(session));
        }

        function loadSession() {
            console.log('ðŸ”µ loadSession() called!');
            const saved = localStorage.getItem('haulerHelperSession');
            console.log('ðŸ”µ Saved data:', saved);
            if (!saved) return;

            isLoadingSession = true; // ðŸ”’ Block saves during load
            
            try {
                const session = JSON.parse(saved);
                
                // Restore selections
                if (session.ship) {
                    selectedShip = ships.find(s => s.id === session.ship);
                    if (selectedShip) {
                        document.getElementById('shipSelect').value = selectedShip.name;
                    }
                }
                if (session.system) {
                    document.getElementById('systemSelect').value = session.system;
                    selectedSystem = session.system;
                }
                if (session.category) {
                    document.getElementById('categorySelect').value = session.category;
                    selectedCategory = session.category;
                }
                
                // Restore missions
                if (session.missions) {
                    missions = session.missions;
                    missionCounter = missions.length;
                    
                    const container = document.getElementById('missionsContainer');
                    container.innerHTML = '';
                    
                    missions.forEach((mission, index) => {
                        const panel = createMissionPanel(mission.id, index + 1);
                        container.appendChild(panel);
                        
                        // Set payout
                        const payoutSelect = panel.querySelector('select');
                        if (payoutSelect && mission.payout) {
                            payoutSelect.value = mission.payout;
                        }
                        
                        // Restore commodities
                        const commoditiesContainer = document.getElementById(`${mission.id}_commodities`);
                        mission.commodities.forEach((commodity, cIndex) => {
                            const row = createCommodityRow(mission.id, commodity.id, cIndex > 0);
                            commoditiesContainer.appendChild(row);
                            
                            // Set values
                            const selects = row.querySelectorAll('select');
                            const input = row.querySelector('input');
                            if (selects[0]) selects[0].value = commodity.pickup || '';
                            if (selects[1]) selects[1].value = commodity.commodity || '';
                            if (input) input.value = commodity.quantity || '';
                            if (selects[2]) selects[2].value = commodity.maxBoxSize || '4';
                            if (selects[3]) selects[3].value = commodity.destination || '';
                        });
                    });
                }
                
                // Restore location colors
                if (session.locationColors) {
                    locationColors = session.locationColors;
                }
                
                // Restore cargo groups
                if (session.cargoGroups) {
                    cargoGroups = session.cargoGroups;
                }
                
                // Generate route plan and cargo grid
                generateRoutePlan();
                generateCargoGrid();
                updateStats();
            } catch (e) {
                console.error('âŒ Error loading session:', e);
                console.error('âŒ Error stack:', e.stack);
            } finally {
        isLoadingSession = false; // ðŸ”“ Allow saves again
    }
}

        // Initialize on load
        window.onload = init;

        // Reset missions only (keep ship, system, category, theme)
        function resetMissions() {
            if (confirm('Clear all missions? This will remove all mission data but keep your ship, system, category, and theme settings.')) {
                // Clear missions
                missions = [];
                missionCounter = 0;
                locationColors = {};
                deliveryOrder = [];
                commodityOrder = [];
                cargoGridOrder = [];
                cargoGroups = {};
                
                // Clear mission panels
                document.getElementById('missionsContainer').innerHTML = '';
                
                // Update displays
                // updateDeliverySummary removed
                updateStats();
                saveSession();
            }
        }

        // Reset function
        function resetAll() {
            if (confirm('Reset everything? This will clear all missions, selections, colors, and preferences. This cannot be undone.')) {
                // Clear all localStorage
                localStorage.removeItem('haulerHelperSession');
                localStorage.removeItem('haulerHelperTheme');
                localStorage.removeItem('haulerHelperDeliveryLayout');
                localStorage.removeItem('haulerHelperDeliveryOrder');
                localStorage.removeItem('haulerHelperCommodityOrder');
                localStorage.removeItem('haulerHelperOrganizerGroupBy');
                
                // Reload the page to reset everything
                location.reload();
            }
        }
    </script>

    <button class="btn-reset" onclick="resetMissions()" title="Clear missions only" style="bottom: 80px;">Reset Missions</button>
    <button class="btn-reset" onclick="resetAll()" title="Reset all data and preferences">Reset All</button>

    <footer class="footer">
        This is an unofficial Star Citizen fansite, not affiliated with the Cloud Imperium group of companies.<br>
        2025 Wednesdaywoe<br>
        <a href="https://www.youtube.com/@wednesdaywoeplays" target="_blank">youtube.com/@wednesdaywoeplays</a>
    </footer>
</body>
</html>